{"ast":null,"code":"/*!\n * Copyright (c) 2010-2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n/* Core API */\n\nconst api = {};\nmodule.exports = api;\n/* API Constants */\n\nconst constants = require('./constants');\n\nObject.assign(api, constants); // TODO: support `ProofChain`\n\nconst ProofSet = require('./ProofSet');\n\nconst VerificationError = require('./VerificationError');\n/**\n * Cryptographically signs the provided document by adding a `proof` section,\n * based on the provided suite and proof purpose.\n *\n * @param {object|string} document - The document to be signed, either a string URL\n *  (resolved to an object via the given `documentLoader`) or a plain object\n *  (JSON-LD document).\n *\n * @param {LinkedDataSignature} suite - The linked data signature cryptographic\n *   suite, containing private key material, with which to sign the document.\n * @param {ProofPurpose} purpose - A proof purpose instance that will\n *   match proofs to be verified and ensure they were created according to\n *   the appropriate purpose.\n *\n * Advanced optional parameters and overrides:\n *\n * @param {function} [documentLoader]  - A custom document loader,\n *   `Promise<RemoteDocument> documentLoader(url)`.\n * @param {function} [expansionMap] - A custom expansion map that is\n *   passed to the JSON-LD processor; by default a function that will throw\n *   an error when unmapped properties are detected in the input, use `false`\n *   to turn this off and allow unmapped properties to be dropped or use a\n *   custom function.\n * @param {boolean} [compactProof=true] - Indicates that this method cannot\n *   assume that the incoming document has defined all proof terms in the\n *   same way as the `constants.SECURITY_CONTEXT_URL` JSON-LD `@context`.\n *   This means that this method must compact any found proofs to this\n *   context for internal and extension processing; this is the default\n *   behavior. To override this behavior and optimize away this step because\n *   the caller knows that the input document's JSON-LD `@context` defines\n *   the proof terms in the same way, set this flag to `false`.\n *\n * @returns {Promise<object>} Resolves with signed document.\n */\n\n\napi.sign = async function sign(document) {\n  let {\n    suite,\n    purpose,\n    documentLoader,\n    expansionMap,\n    compactProof\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  try {\n    return await new ProofSet().add(document, {\n      suite,\n      purpose,\n      documentLoader,\n      expansionMap,\n      compactProof\n    });\n  } catch (e) {\n    if (!documentLoader && e.name === 'jsonld.InvalidUrl') {\n      const {\n        details: {\n          url\n        }\n      } = e;\n      const err = new Error(`A URL \"${url}\" could not be fetched; you need to pass ` + '\"documentLoader\" or resolve the URL before calling \"sign\".');\n      err.cause = e;\n      throw err;\n    }\n\n    throw e;\n  }\n};\n/**\n * Verifies the linked data signature on the provided document.\n *\n * @param {object|string} document - The document with one or more proofs to be\n *   verified, either a string URL (resolved to an object via the given\n *   `documentLoader`) or a plain object (JSON-LD document).\n *\n * @param {LinkedDataSignature|LinkedDataSignature[]} suite -\n *   Acceptable signature suite instances for verifying the proof(s).\n *\n * @param {ProofPurpose} purpose - A proof purpose instance that will\n *   match proofs to be verified and ensure they were created according to\n *   the appropriate purpose.\n *\n * Advanced optional parameters and overrides:\n *\n * @param {function} [documentLoader]  - A custom document loader,\n *   `Promise<RemoteDocument> documentLoader(url)`.\n * @param {function} [expansionMap] - A custom expansion map that is\n *   passed to the JSON-LD processor; by default a function that will throw\n *   an error when unmapped properties are detected in the input, use `false`\n *   to turn this off and allow unmapped properties to be dropped or use a\n *   custom function.\n * @param {boolean} [compactProof=true] - Indicates that this method cannot\n *   assume that the incoming document has defined all proof terms in the\n *   same way as the `constants.SECURITY_CONTEXT_URL` JSON-LD `@context`.\n *   This means that this method must compact any found proofs to this\n *   context for internal and extension processing; this is the default\n *   behavior. To override this behavior and optimize away this step because\n *   the caller knows that the input document's JSON-LD `@context` defines\n *   the proof terms in the same way, set this flag to `false`.\n *\n * @return {Promise<{verified: boolean, results: Array, error: VerificationError}>}\n *   resolves with an object with a `verified` boolean property that is `true`\n *   if at least one proof matching the given purpose and suite verifies and\n *   `false` otherwise; a `results` property with an array of detailed results;\n *   if `false` an `error` property will be present, with `error.errors`\n *   containing all of the errors that occurred during the verification process.\n */\n\n\napi.verify = async function verify(document) {\n  let {\n    suite,\n    purpose,\n    documentLoader,\n    expansionMap,\n    compactProof\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const result = await new ProofSet().verify(document, {\n    suite,\n    purpose,\n    documentLoader,\n    expansionMap,\n    compactProof\n  });\n  const {\n    error\n  } = result;\n\n  if (error) {\n    if (!documentLoader && error.name === 'jsonld.InvalidUrl') {\n      const {\n        details: {\n          url\n        }\n      } = error;\n      const urlError = new Error(`A URL \"${url}\" could not be fetched; you need to pass ` + '\"documentLoader\" or resolve the URL before calling \"verify\".');\n      result.error = new VerificationError(urlError);\n    } else {\n      result.error = new VerificationError(error);\n    }\n  }\n\n  return result;\n}; // expose suite classes\n\n\napi.suites = require('./suites').suites; // expose ProofPurpose classes to enable extensions\n\napi.purposes = require('./purposes').purposes; // expose LDKeyPair classes\n\nObject.assign(api, require('crypto-ld')); // expose document loader helpers\n\nObject.assign(api, require('./documentLoader'));","map":{"version":3,"sources":["/Users/shubhamlal/Desktop/verification/node_modules/jsonld-signatures/lib/jsonld-signatures.js"],"names":["api","module","exports","constants","require","Object","assign","ProofSet","VerificationError","sign","document","suite","purpose","documentLoader","expansionMap","compactProof","add","e","name","details","url","err","Error","cause","verify","result","error","urlError","suites","purposes"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2010-2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\n/* Core API */\nconst api = {};\nmodule.exports = api;\n\n/* API Constants */\nconst constants = require('./constants');\nObject.assign(api, constants);\n\n// TODO: support `ProofChain`\nconst ProofSet = require('./ProofSet');\nconst VerificationError = require('./VerificationError');\n\n/**\n * Cryptographically signs the provided document by adding a `proof` section,\n * based on the provided suite and proof purpose.\n *\n * @param {object|string} document - The document to be signed, either a string URL\n *  (resolved to an object via the given `documentLoader`) or a plain object\n *  (JSON-LD document).\n *\n * @param {LinkedDataSignature} suite - The linked data signature cryptographic\n *   suite, containing private key material, with which to sign the document.\n * @param {ProofPurpose} purpose - A proof purpose instance that will\n *   match proofs to be verified and ensure they were created according to\n *   the appropriate purpose.\n *\n * Advanced optional parameters and overrides:\n *\n * @param {function} [documentLoader]  - A custom document loader,\n *   `Promise<RemoteDocument> documentLoader(url)`.\n * @param {function} [expansionMap] - A custom expansion map that is\n *   passed to the JSON-LD processor; by default a function that will throw\n *   an error when unmapped properties are detected in the input, use `false`\n *   to turn this off and allow unmapped properties to be dropped or use a\n *   custom function.\n * @param {boolean} [compactProof=true] - Indicates that this method cannot\n *   assume that the incoming document has defined all proof terms in the\n *   same way as the `constants.SECURITY_CONTEXT_URL` JSON-LD `@context`.\n *   This means that this method must compact any found proofs to this\n *   context for internal and extension processing; this is the default\n *   behavior. To override this behavior and optimize away this step because\n *   the caller knows that the input document's JSON-LD `@context` defines\n *   the proof terms in the same way, set this flag to `false`.\n *\n * @returns {Promise<object>} Resolves with signed document.\n */\napi.sign = async function sign(document, {\n  suite, purpose, documentLoader, expansionMap, compactProof} = {}) {\n  try {\n    return await new ProofSet().add(\n      document, {suite, purpose, documentLoader, expansionMap, compactProof});\n  } catch(e) {\n    if(!documentLoader && e.name === 'jsonld.InvalidUrl') {\n      const {details: {url}} = e;\n      const err = new Error(\n        `A URL \"${url}\" could not be fetched; you need to pass ` +\n        '\"documentLoader\" or resolve the URL before calling \"sign\".');\n      err.cause = e;\n      throw err;\n    }\n    throw e;\n  }\n};\n\n/**\n * Verifies the linked data signature on the provided document.\n *\n * @param {object|string} document - The document with one or more proofs to be\n *   verified, either a string URL (resolved to an object via the given\n *   `documentLoader`) or a plain object (JSON-LD document).\n *\n * @param {LinkedDataSignature|LinkedDataSignature[]} suite -\n *   Acceptable signature suite instances for verifying the proof(s).\n *\n * @param {ProofPurpose} purpose - A proof purpose instance that will\n *   match proofs to be verified and ensure they were created according to\n *   the appropriate purpose.\n *\n * Advanced optional parameters and overrides:\n *\n * @param {function} [documentLoader]  - A custom document loader,\n *   `Promise<RemoteDocument> documentLoader(url)`.\n * @param {function} [expansionMap] - A custom expansion map that is\n *   passed to the JSON-LD processor; by default a function that will throw\n *   an error when unmapped properties are detected in the input, use `false`\n *   to turn this off and allow unmapped properties to be dropped or use a\n *   custom function.\n * @param {boolean} [compactProof=true] - Indicates that this method cannot\n *   assume that the incoming document has defined all proof terms in the\n *   same way as the `constants.SECURITY_CONTEXT_URL` JSON-LD `@context`.\n *   This means that this method must compact any found proofs to this\n *   context for internal and extension processing; this is the default\n *   behavior. To override this behavior and optimize away this step because\n *   the caller knows that the input document's JSON-LD `@context` defines\n *   the proof terms in the same way, set this flag to `false`.\n *\n * @return {Promise<{verified: boolean, results: Array, error: VerificationError}>}\n *   resolves with an object with a `verified` boolean property that is `true`\n *   if at least one proof matching the given purpose and suite verifies and\n *   `false` otherwise; a `results` property with an array of detailed results;\n *   if `false` an `error` property will be present, with `error.errors`\n *   containing all of the errors that occurred during the verification process.\n */\napi.verify = async function verify(document, {\n  suite, purpose, documentLoader, expansionMap, compactProof} = {}) {\n  const result = await new ProofSet().verify(\n    document, {suite, purpose, documentLoader, expansionMap, compactProof});\n  const {error} = result;\n  if(error) {\n    if(!documentLoader && error.name === 'jsonld.InvalidUrl') {\n      const {details: {url}} = error;\n      const urlError = new Error(\n        `A URL \"${url}\" could not be fetched; you need to pass ` +\n        '\"documentLoader\" or resolve the URL before calling \"verify\".');\n      result.error = new VerificationError(urlError);\n    } else {\n      result.error = new VerificationError(error);\n    }\n  }\n  return result;\n};\n\n// expose suite classes\napi.suites = require('./suites').suites;\n\n// expose ProofPurpose classes to enable extensions\napi.purposes = require('./purposes').purposes;\n\n// expose LDKeyPair classes\nObject.assign(api, require('crypto-ld'));\n\n// expose document loader helpers\nObject.assign(api, require('./documentLoader'));\n"]},"metadata":{},"sourceType":"script"}