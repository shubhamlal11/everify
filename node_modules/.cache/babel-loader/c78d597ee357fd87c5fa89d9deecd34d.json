{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst JsonLdError = require('./JsonLdError');\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = require('./types');\n\nconst {\n  isList: _isList,\n  isValue: _isValue,\n  isGraph: _isGraph,\n  isSimpleGraph: _isSimpleGraph,\n  isSubjectReference: _isSubjectReference\n} = require('./graphTypes');\n\nconst {\n  expandIri: _expandIri,\n  getContextValue: _getContextValue,\n  isKeyword: _isKeyword,\n  process: _processContext,\n  processingMode: _processingMode\n} = require('./context');\n\nconst {\n  removeBase: _removeBase\n} = require('./url');\n\nconst {\n  addValue: _addValue,\n  asArray: _asArray,\n  compareShortestLeast: _compareShortestLeast\n} = require('./util');\n\nconst api = {};\nmodule.exports = api;\n/**\n * Recursively compacts an element using the given active context. All values\n * must be in expanded form before this method is called.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the compacted property associated with the element\n *          to compact, null for none.\n * @param element the element to compact.\n * @param options the compaction options.\n * @param compactionMap the compaction map to use.\n *\n * @return a promise that resolves to the compacted value.\n */\n\napi.compact = async _ref => {\n  let {\n    activeCtx,\n    activeProperty = null,\n    element,\n    options = {},\n    compactionMap = () => undefined\n  } = _ref;\n\n  // recursively compact array\n  if (_isArray(element)) {\n    let rval = [];\n\n    for (let i = 0; i < element.length; ++i) {\n      // compact, dropping any null values unless custom mapped\n      let compacted = await api.compact({\n        activeCtx,\n        activeProperty,\n        element: element[i],\n        options,\n        compactionMap\n      });\n\n      if (compacted === null) {\n        compacted = await compactionMap({\n          unmappedValue: element[i],\n          activeCtx,\n          activeProperty,\n          parent: element,\n          index: i,\n          options\n        });\n\n        if (compacted === undefined) {\n          continue;\n        }\n      }\n\n      rval.push(compacted);\n    }\n\n    if (options.compactArrays && rval.length === 1) {\n      // use single element if no container is specified\n      const container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n      if (container.length === 0) {\n        rval = rval[0];\n      }\n    }\n\n    return rval;\n  } // use any scoped context on activeProperty\n\n\n  const ctx = _getContextValue(activeCtx, activeProperty, '@context');\n\n  if (!_isUndefined(ctx)) {\n    activeCtx = await _processContext({\n      activeCtx,\n      localCtx: ctx,\n      propagate: true,\n      overrideProtected: true,\n      options\n    });\n  } // recursively compact object\n\n\n  if (_isObject(element)) {\n    if (options.link && '@id' in element && options.link.hasOwnProperty(element['@id'])) {\n      // check for a linked element to reuse\n      const linked = options.link[element['@id']];\n\n      for (let i = 0; i < linked.length; ++i) {\n        if (linked[i].expanded === element) {\n          return linked[i].compacted;\n        }\n      }\n    } // do value compaction on @values and subject references\n\n\n    if (_isValue(element) || _isSubjectReference(element)) {\n      const rval = api.compactValue({\n        activeCtx,\n        activeProperty,\n        value: element,\n        options\n      });\n\n      if (options.link && _isSubjectReference(element)) {\n        // store linked element\n        if (!options.link.hasOwnProperty(element['@id'])) {\n          options.link[element['@id']] = [];\n        }\n\n        options.link[element['@id']].push({\n          expanded: element,\n          compacted: rval\n        });\n      }\n\n      return rval;\n    } // if expanded property is @list and we're contained within a list\n    // container, recursively compact this item to an array\n\n\n    if (_isList(element)) {\n      const container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n      if (container.includes('@list')) {\n        return api.compact({\n          activeCtx,\n          activeProperty,\n          element: element['@list'],\n          options,\n          compactionMap\n        });\n      }\n    } // FIXME: avoid misuse of active property as an expanded property?\n\n\n    const insideReverse = activeProperty === '@reverse';\n    const rval = {}; // original context before applying property-scoped and local contexts\n\n    const inputCtx = activeCtx; // revert to previous context, if there is one,\n    // and element is not a value object or a node reference\n\n    if (!_isValue(element) && !_isSubjectReference(element)) {\n      activeCtx = activeCtx.revertToPreviousContext();\n    } // apply property-scoped context after reverting term-scoped context\n\n\n    const propertyScopedCtx = _getContextValue(inputCtx, activeProperty, '@context');\n\n    if (!_isUndefined(propertyScopedCtx)) {\n      activeCtx = await _processContext({\n        activeCtx,\n        localCtx: propertyScopedCtx,\n        propagate: true,\n        overrideProtected: true,\n        options\n      });\n    }\n\n    if (options.link && '@id' in element) {\n      // store linked element\n      if (!options.link.hasOwnProperty(element['@id'])) {\n        options.link[element['@id']] = [];\n      }\n\n      options.link[element['@id']].push({\n        expanded: element,\n        compacted: rval\n      });\n    } // apply any context defined on an alias of @type\n    // if key is @type and any compacted value is a term having a local\n    // context, overlay that context\n\n\n    let types = element['@type'] || [];\n\n    if (types.length > 1) {\n      types = Array.from(types).sort();\n    } // find all type-scoped contexts based on current context, prior to\n    // updating it\n\n\n    const typeContext = activeCtx;\n\n    for (const type of types) {\n      const compactedType = api.compactIri({\n        activeCtx: typeContext,\n        iri: type,\n        relativeTo: {\n          vocab: true\n        }\n      }); // Use any type-scoped context defined on this value\n\n      const ctx = _getContextValue(inputCtx, compactedType, '@context');\n\n      if (!_isUndefined(ctx)) {\n        activeCtx = await _processContext({\n          activeCtx,\n          localCtx: ctx,\n          options,\n          propagate: false\n        });\n      }\n    } // process element keys in order\n\n\n    const keys = Object.keys(element).sort();\n\n    for (const expandedProperty of keys) {\n      const expandedValue = element[expandedProperty]; // compact @id\n\n      if (expandedProperty === '@id') {\n        let compactedValue = _asArray(expandedValue).map(expandedIri => api.compactIri({\n          activeCtx,\n          iri: expandedIri,\n          relativeTo: {\n            vocab: false\n          }\n        }));\n\n        if (compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        } // use keyword alias and add value\n\n\n        const alias = api.compactIri({\n          activeCtx,\n          iri: '@id',\n          relativeTo: {\n            vocab: true\n          }\n        });\n        rval[alias] = compactedValue;\n        continue;\n      } // compact @type(s)\n\n\n      if (expandedProperty === '@type') {\n        // resolve type values against previous context\n        let compactedValue = _asArray(expandedValue).map(expandedIri => api.compactIri({\n          activeCtx: inputCtx,\n          iri: expandedIri,\n          relativeTo: {\n            vocab: true\n          }\n        }));\n\n        if (compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        } // use keyword alias and add value\n\n\n        const alias = api.compactIri({\n          activeCtx,\n          iri: '@type',\n          relativeTo: {\n            vocab: true\n          }\n        });\n        const container = _getContextValue(activeCtx, alias, '@container') || []; // treat as array for @type if @container includes @set\n\n        const typeAsSet = container.includes('@set') && _processingMode(activeCtx, 1.1);\n\n        const isArray = typeAsSet || _isArray(compactedValue) && expandedValue.length === 0;\n\n        _addValue(rval, alias, compactedValue, {\n          propertyIsArray: isArray\n        });\n\n        continue;\n      } // handle @reverse\n\n\n      if (expandedProperty === '@reverse') {\n        // recursively compact expanded value\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty: '@reverse',\n          element: expandedValue,\n          options,\n          compactionMap\n        }); // handle double-reversed properties\n\n        for (const compactedProperty in compactedValue) {\n          if (activeCtx.mappings.has(compactedProperty) && activeCtx.mappings.get(compactedProperty).reverse) {\n            const value = compactedValue[compactedProperty];\n            const container = _getContextValue(activeCtx, compactedProperty, '@container') || [];\n            const useArray = container.includes('@set') || !options.compactArrays;\n\n            _addValue(rval, compactedProperty, value, {\n              propertyIsArray: useArray\n            });\n\n            delete compactedValue[compactedProperty];\n          }\n        }\n\n        if (Object.keys(compactedValue).length > 0) {\n          // use keyword alias and add value\n          const alias = api.compactIri({\n            activeCtx,\n            iri: expandedProperty,\n            relativeTo: {\n              vocab: true\n            }\n          });\n\n          _addValue(rval, alias, compactedValue);\n        }\n\n        continue;\n      }\n\n      if (expandedProperty === '@preserve') {\n        // compact using activeProperty\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty,\n          element: expandedValue,\n          options,\n          compactionMap\n        });\n\n        if (!(_isArray(compactedValue) && compactedValue.length === 0)) {\n          _addValue(rval, expandedProperty, compactedValue);\n        }\n\n        continue;\n      } // handle @index property\n\n\n      if (expandedProperty === '@index') {\n        // drop @index if inside an @index container\n        const container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n        if (container.includes('@index')) {\n          continue;\n        } // use keyword alias and add value\n\n\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {\n            vocab: true\n          }\n        });\n\n        _addValue(rval, alias, expandedValue);\n\n        continue;\n      } // skip array processing for keywords that aren't @graph or @list\n\n\n      if (expandedProperty !== '@graph' && expandedProperty !== '@list' && _isKeyword(expandedProperty)) {\n        // use keyword alias and add value as is\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {\n            vocab: true\n          }\n        });\n\n        _addValue(rval, alias, expandedValue);\n\n        continue;\n      } // Note: expanded value must be an array due to expansion algorithm.\n\n\n      if (!_isArray(expandedValue)) {\n        throw new JsonLdError('JSON-LD expansion error; expanded value must be an array.', 'jsonld.SyntaxError');\n      } // preserve empty arrays\n\n\n      if (expandedValue.length === 0) {\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedValue,\n          relativeTo: {\n            vocab: true\n          },\n          reverse: insideReverse\n        });\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ? activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n\n        if (nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n\n          if (!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n\n          nestResult = rval[nestProperty];\n        }\n\n        _addValue(nestResult, itemActiveProperty, expandedValue, {\n          propertyIsArray: true\n        });\n      } // recusively process array values\n\n\n      for (const expandedItem of expandedValue) {\n        // compact property and get container type\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedItem,\n          relativeTo: {\n            vocab: true\n          },\n          reverse: insideReverse\n        }); // if itemActiveProperty is a @nest property, add values to nestResult,\n        // otherwise rval\n\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ? activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n\n        if (nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n\n          if (!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n\n          nestResult = rval[nestProperty];\n        }\n\n        const container = _getContextValue(activeCtx, itemActiveProperty, '@container') || []; // get simple @graph or @list value if appropriate\n\n        const isGraph = _isGraph(expandedItem);\n\n        const isList = _isList(expandedItem);\n\n        let inner;\n\n        if (isList) {\n          inner = expandedItem['@list'];\n        } else if (isGraph) {\n          inner = expandedItem['@graph'];\n        } // recursively compact expanded item\n\n\n        let compactedItem = await api.compact({\n          activeCtx,\n          activeProperty: itemActiveProperty,\n          element: isList || isGraph ? inner : expandedItem,\n          options,\n          compactionMap\n        }); // handle @list\n\n        if (isList) {\n          // ensure @list value is an array\n          if (!_isArray(compactedItem)) {\n            compactedItem = [compactedItem];\n          }\n\n          if (!container.includes('@list')) {\n            // wrap using @list alias\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@list',\n                relativeTo: {\n                  vocab: true\n                }\n              })]: compactedItem\n            }; // include @index from expanded @list, if any\n\n            if ('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {\n                  vocab: true\n                }\n              })] = expandedItem['@index'];\n            }\n          } else {\n            _addValue(nestResult, itemActiveProperty, compactedItem, {\n              valueIsArray: true,\n              allowDuplicate: true\n            });\n\n            continue;\n          }\n        } // Graph object compaction cases\n\n\n        if (isGraph) {\n          if (container.includes('@graph') && (container.includes('@id') || container.includes('@index') && _isSimpleGraph(expandedItem))) {\n            // get or create the map object\n            let mapObject;\n\n            if (nestResult.hasOwnProperty(itemActiveProperty)) {\n              mapObject = nestResult[itemActiveProperty];\n            } else {\n              nestResult[itemActiveProperty] = mapObject = {};\n            } // index on @id or @index or alias of @none\n\n\n            const key = (container.includes('@id') ? expandedItem['@id'] : expandedItem['@index']) || api.compactIri({\n              activeCtx,\n              iri: '@none',\n              vocab: true\n            }); // add compactedItem to map, using value of `@id` or a new blank\n            // node identifier\n\n            _addValue(mapObject, key, compactedItem, {\n              propertyIsArray: !options.compactArrays || container.includes('@set')\n            });\n          } else if (container.includes('@graph') && _isSimpleGraph(expandedItem)) {\n            // container includes @graph but not @id or @index and value is a\n            // simple graph object add compact value\n            // if compactedItem contains multiple values, it is wrapped in\n            // `@included`\n            if (_isArray(compactedItem) && compactedItem.length > 1) {\n              compactedItem = {\n                '@included': compactedItem\n              };\n            }\n\n            _addValue(nestResult, itemActiveProperty, compactedItem, {\n              propertyIsArray: !options.compactArrays || container.includes('@set')\n            });\n          } else {\n            // wrap using @graph alias, remove array if only one item and\n            // compactArrays not set\n            if (_isArray(compactedItem) && compactedItem.length === 1 && options.compactArrays) {\n              compactedItem = compactedItem[0];\n            }\n\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@graph',\n                relativeTo: {\n                  vocab: true\n                }\n              })]: compactedItem\n            }; // include @id from expanded graph, if any\n\n            if ('@id' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@id',\n                relativeTo: {\n                  vocab: true\n                }\n              })] = expandedItem['@id'];\n            } // include @index from expanded graph, if any\n\n\n            if ('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {\n                  vocab: true\n                }\n              })] = expandedItem['@index'];\n            }\n\n            _addValue(nestResult, itemActiveProperty, compactedItem, {\n              propertyIsArray: !options.compactArrays || container.includes('@set')\n            });\n          }\n        } else if (container.includes('@language') || container.includes('@index') || container.includes('@id') || container.includes('@type')) {\n          // handle language and index maps\n          // get or create the map object\n          let mapObject;\n\n          if (nestResult.hasOwnProperty(itemActiveProperty)) {\n            mapObject = nestResult[itemActiveProperty];\n          } else {\n            nestResult[itemActiveProperty] = mapObject = {};\n          }\n\n          let key;\n\n          if (container.includes('@language')) {\n            // if container is a language map, simplify compacted value to\n            // a simple string\n            if (_isValue(compactedItem)) {\n              compactedItem = compactedItem['@value'];\n            }\n\n            key = expandedItem['@language'];\n          } else if (container.includes('@index')) {\n            const indexKey = _getContextValue(activeCtx, itemActiveProperty, '@index') || '@index';\n            const containerKey = api.compactIri({\n              activeCtx,\n              iri: indexKey,\n              vocab: true\n            });\n\n            if (indexKey === '@index') {\n              key = expandedItem['@index'];\n              delete compactedItem[containerKey];\n            } else {\n              let others;\n              [key, ...others] = _asArray(compactedItem[indexKey] || []);\n\n              if (!_isString(key)) {\n                // Will use @none if it isn't a string.\n                key = null;\n              } else {\n                switch (others.length) {\n                  case 0:\n                    delete compactedItem[indexKey];\n                    break;\n\n                  case 1:\n                    compactedItem[indexKey] = others[0];\n                    break;\n\n                  default:\n                    compactedItem[indexKey] = others;\n                    break;\n                }\n              }\n            }\n          } else if (container.includes('@id')) {\n            const idKey = api.compactIri({\n              activeCtx,\n              iri: '@id',\n              vocab: true\n            });\n            key = compactedItem[idKey];\n            delete compactedItem[idKey];\n          } else if (container.includes('@type')) {\n            const typeKey = api.compactIri({\n              activeCtx,\n              iri: '@type',\n              vocab: true\n            });\n            let types;\n            [key, ...types] = _asArray(compactedItem[typeKey] || []);\n\n            switch (types.length) {\n              case 0:\n                delete compactedItem[typeKey];\n                break;\n\n              case 1:\n                compactedItem[typeKey] = types[0];\n                break;\n\n              default:\n                compactedItem[typeKey] = types;\n                break;\n            } // If compactedItem contains a single entry\n            // whose key maps to @id, recompact without @type\n\n\n            if (Object.keys(compactedItem).length === 1 && '@id' in expandedItem) {\n              compactedItem = await api.compact({\n                activeCtx,\n                activeProperty: itemActiveProperty,\n                element: {\n                  '@id': expandedItem['@id']\n                },\n                options,\n                compactionMap\n              });\n            }\n          } // if compacting this value which has no key, index on @none\n\n\n          if (!key) {\n            key = api.compactIri({\n              activeCtx,\n              iri: '@none',\n              vocab: true\n            });\n          } // add compact value to map object using key from expanded value\n          // based on the container type\n\n\n          _addValue(mapObject, key, compactedItem, {\n            propertyIsArray: container.includes('@set')\n          });\n        } else {\n          // use an array if: compactArrays flag is false,\n          // @container is @set or @list , value is an empty\n          // array, or key is @graph\n          const isArray = !options.compactArrays || container.includes('@set') || container.includes('@list') || _isArray(compactedItem) && compactedItem.length === 0 || expandedProperty === '@list' || expandedProperty === '@graph'; // add compact value\n\n          _addValue(nestResult, itemActiveProperty, compactedItem, {\n            propertyIsArray: isArray\n          });\n        }\n      }\n    }\n\n    return rval;\n  } // only primitives remain which are already compact\n\n\n  return element;\n};\n/**\n * Compacts an IRI or keyword into a term or prefix if it can be. If the\n * IRI has an associated value it may be passed.\n *\n * @param activeCtx the active context to use.\n * @param iri the IRI to compact.\n * @param value the value to check or null.\n * @param relativeTo options for how to compact IRIs:\n *          vocab: true to split after @vocab, false not to.\n * @param reverse true if a reverse property is being compacted, false if not.\n *\n * @return the compacted term, prefix, keyword alias, or the original IRI.\n */\n\n\napi.compactIri = _ref2 => {\n  let {\n    activeCtx,\n    iri,\n    value = null,\n    relativeTo = {\n      vocab: false\n    },\n    reverse = false\n  } = _ref2;\n\n  // can't compact null\n  if (iri === null) {\n    return iri;\n  } // if context is from a property term scoped context composed with a\n  // type-scoped context, then use the previous context instead\n\n\n  if (activeCtx.isPropertyTermScoped && activeCtx.previousContext) {\n    activeCtx = activeCtx.previousContext;\n  }\n\n  const inverseCtx = activeCtx.getInverse(); // if term is a keyword, it may be compacted to a simple alias\n\n  if (_isKeyword(iri) && iri in inverseCtx && '@none' in inverseCtx[iri] && '@type' in inverseCtx[iri]['@none'] && '@none' in inverseCtx[iri]['@none']['@type']) {\n    return inverseCtx[iri]['@none']['@type']['@none'];\n  } // use inverse context to pick a term if iri is relative to vocab\n\n\n  if (relativeTo.vocab && iri in inverseCtx) {\n    const defaultLanguage = activeCtx['@language'] || '@none'; // prefer @index if available in value\n\n    const containers = [];\n\n    if (_isObject(value) && '@index' in value && !('@graph' in value)) {\n      containers.push('@index', '@index@set');\n    } // if value is a preserve object, use its value\n\n\n    if (_isObject(value) && '@preserve' in value) {\n      value = value['@preserve'][0];\n    } // prefer most specific container including @graph, prefering @set\n    // variations\n\n\n    if (_isGraph(value)) {\n      // favor indexmap if the graph is indexed\n      if ('@index' in value) {\n        containers.push('@graph@index', '@graph@index@set', '@index', '@index@set');\n      } // favor idmap if the graph is has an @id\n\n\n      if ('@id' in value) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n\n      containers.push('@graph', '@graph@set', '@set'); // allow indexmap if the graph is not indexed\n\n      if (!('@index' in value)) {\n        containers.push('@graph@index', '@graph@index@set', '@index', '@index@set');\n      } // allow idmap if the graph does not have an @id\n\n\n      if (!('@id' in value)) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n    } else if (_isObject(value) && !_isValue(value)) {\n      containers.push('@id', '@id@set', '@type', '@set@type');\n    } // defaults for term selection based on type/language\n\n\n    let typeOrLanguage = '@language';\n    let typeOrLanguageValue = '@null';\n\n    if (reverse) {\n      typeOrLanguage = '@type';\n      typeOrLanguageValue = '@reverse';\n      containers.push('@set');\n    } else if (_isList(value)) {\n      // choose the most specific term that works for all elements in @list\n      // only select @list containers if @index is NOT in value\n      if (!('@index' in value)) {\n        containers.push('@list');\n      }\n\n      const list = value['@list'];\n\n      if (list.length === 0) {\n        // any empty list can be matched against any term that uses the\n        // @list container regardless of @type or @language\n        typeOrLanguage = '@any';\n        typeOrLanguageValue = '@none';\n      } else {\n        let commonLanguage = list.length === 0 ? defaultLanguage : null;\n        let commonType = null;\n\n        for (let i = 0; i < list.length; ++i) {\n          const item = list[i];\n          let itemLanguage = '@none';\n          let itemType = '@none';\n\n          if (_isValue(item)) {\n            if ('@language' in item) {\n              itemLanguage = item['@language'];\n            } else if ('@type' in item) {\n              itemType = item['@type'];\n            } else {\n              // plain literal\n              itemLanguage = '@null';\n            }\n          } else {\n            itemType = '@id';\n          }\n\n          if (commonLanguage === null) {\n            commonLanguage = itemLanguage;\n          } else if (itemLanguage !== commonLanguage && _isValue(item)) {\n            commonLanguage = '@none';\n          }\n\n          if (commonType === null) {\n            commonType = itemType;\n          } else if (itemType !== commonType) {\n            commonType = '@none';\n          } // there are different languages and types in the list, so choose\n          // the most generic term, no need to keep iterating the list\n\n\n          if (commonLanguage === '@none' && commonType === '@none') {\n            break;\n          }\n        }\n\n        commonLanguage = commonLanguage || '@none';\n        commonType = commonType || '@none';\n\n        if (commonType !== '@none') {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = commonType;\n        } else {\n          typeOrLanguageValue = commonLanguage;\n        }\n      }\n    } else {\n      if (_isValue(value)) {\n        if ('@language' in value && !('@index' in value)) {\n          containers.push('@language', '@language@set');\n          typeOrLanguageValue = value['@language'];\n        } else if ('@type' in value) {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = value['@type'];\n        }\n      } else {\n        typeOrLanguage = '@type';\n        typeOrLanguageValue = '@id';\n      }\n\n      containers.push('@set');\n    } // do term selection\n\n\n    containers.push('@none'); // an index map can be used to index values using @none, so add as a low\n    // priority\n\n    if (_isObject(value) && !('@index' in value)) {\n      // allow indexing even if no @index present\n      containers.push('@index', '@index@set');\n    } // values without type or language can use @language map\n\n\n    if (_isValue(value) && Object.keys(value).length === 1) {\n      // allow indexing even if no @index present\n      containers.push('@language', '@language@set');\n    }\n\n    const term = _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);\n\n    if (term !== null) {\n      return term;\n    }\n  } // no term match, use @vocab if available\n\n\n  if (relativeTo.vocab) {\n    if ('@vocab' in activeCtx) {\n      // determine if vocab is a prefix of the iri\n      const vocab = activeCtx['@vocab'];\n\n      if (iri.indexOf(vocab) === 0 && iri !== vocab) {\n        // use suffix as relative iri if it is not a term in the active context\n        const suffix = iri.substr(vocab.length);\n\n        if (!activeCtx.mappings.has(suffix)) {\n          return suffix;\n        }\n      }\n    }\n  } // no term or @vocab match, check for possible CURIEs\n\n\n  let choice = null; // TODO: make FastCurieMap a class with a method to do this lookup\n\n  const partialMatches = [];\n  let iriMap = activeCtx.fastCurieMap; // check for partial matches of against `iri`, which means look until\n  // iri.length - 1, not full length\n\n  const maxPartialLength = iri.length - 1;\n\n  for (let i = 0; i < maxPartialLength && iri[i] in iriMap; ++i) {\n    iriMap = iriMap[iri[i]];\n\n    if ('' in iriMap) {\n      partialMatches.push(iriMap[''][0]);\n    }\n  } // check partial matches in reverse order to prefer longest ones first\n\n\n  for (let i = partialMatches.length - 1; i >= 0; --i) {\n    const entry = partialMatches[i];\n    const terms = entry.terms;\n\n    for (const term of terms) {\n      // a CURIE is usable if:\n      // 1. it has no mapping, OR\n      // 2. value is null, which means we're not compacting an @value, AND\n      //   the mapping matches the IRI\n      const curie = term + ':' + iri.substr(entry.iri.length);\n      const isUsableCurie = activeCtx.mappings.get(term)._prefix && (!activeCtx.mappings.has(curie) || value === null && activeCtx.mappings.get(curie)['@id'] === iri); // select curie if it is shorter or the same length but lexicographically\n      // less than the current choice\n\n      if (isUsableCurie && (choice === null || _compareShortestLeast(curie, choice) < 0)) {\n        choice = curie;\n      }\n    }\n  } // return chosen curie\n\n\n  if (choice !== null) {\n    return choice;\n  } // If iri could be confused with a compact IRI using a term in this context,\n  // signal an error\n\n\n  for (const [term, td] of activeCtx.mappings) {\n    if (td && td._prefix && iri.startsWith(term + ':')) {\n      throw new JsonLdError(`Absolute IRI \"${iri}\" confused with prefix \"${term}\".`, 'jsonld.SyntaxError', {\n        code: 'IRI confused with prefix',\n        context: activeCtx\n      });\n    }\n  } // compact IRI relative to base\n\n\n  if (!relativeTo.vocab) {\n    return _removeBase(activeCtx['@base'], iri);\n  } // return IRI as is\n\n\n  return iri;\n};\n/**\n * Performs value compaction on an object with '@value' or '@id' as the only\n * property.\n *\n * @param activeCtx the active context.\n * @param activeProperty the active property that points to the value.\n * @param value the value to compact.\n * @param {Object} [options] - processing options.\n *\n * @return the compaction result.\n */\n\n\napi.compactValue = _ref3 => {\n  let {\n    activeCtx,\n    activeProperty,\n    value,\n    options\n  } = _ref3;\n\n  // value is a @value\n  if (_isValue(value)) {\n    // get context rules\n    const type = _getContextValue(activeCtx, activeProperty, '@type');\n\n    const language = _getContextValue(activeCtx, activeProperty, '@language');\n\n    const container = _getContextValue(activeCtx, activeProperty, '@container') || []; // whether or not the value has an @index that must be preserved\n\n    const preserveIndex = '@index' in value && !container.includes('@index'); // if there's no @index to preserve ...\n\n    if (!preserveIndex && type !== '@none') {\n      // matching @type or @language specified in context, compact value\n      if (value['@type'] === type || value['@language'] === language) {\n        return value['@value'];\n      }\n    } // return just the value of @value if all are true:\n    // 1. @value is the only key or @index isn't being preserved\n    // 2. there is no default language or @value is not a string or\n    //   the key has a mapping with a null @language\n\n\n    const keyCount = Object.keys(value).length;\n    const isValueOnlyKey = keyCount === 1 || keyCount === 2 && '@index' in value && !preserveIndex;\n    const hasDefaultLanguage = ('@language' in activeCtx);\n\n    const isValueString = _isString(value['@value']);\n\n    const hasNullMapping = activeCtx.mappings.has(activeProperty) && activeCtx.mappings.get(activeProperty)['@language'] === null;\n\n    if (isValueOnlyKey && type !== '@none' && (!hasDefaultLanguage || !isValueString || hasNullMapping)) {\n      return value['@value'];\n    }\n\n    const rval = {}; // preserve @index\n\n    if (preserveIndex) {\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@index',\n        relativeTo: {\n          vocab: true\n        }\n      })] = value['@index'];\n    }\n\n    if ('@type' in value) {\n      // compact @type IRI\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@type',\n        relativeTo: {\n          vocab: true\n        }\n      })] = api.compactIri({\n        activeCtx,\n        iri: value['@type'],\n        relativeTo: {\n          vocab: true\n        }\n      });\n    } else if ('@language' in value) {\n      // alias @language\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@language',\n        relativeTo: {\n          vocab: true\n        }\n      })] = value['@language'];\n    } // alias @value\n\n\n    rval[api.compactIri({\n      activeCtx,\n      iri: '@value',\n      relativeTo: {\n        vocab: true\n      }\n    })] = value['@value'];\n    return rval;\n  } // value is a subject reference\n\n\n  const expandedProperty = _expandIri(activeCtx, activeProperty, {\n    vocab: true\n  }, options);\n\n  const type = _getContextValue(activeCtx, activeProperty, '@type');\n\n  const compacted = api.compactIri({\n    activeCtx,\n    iri: value['@id'],\n    relativeTo: {\n      vocab: type === '@vocab'\n    }\n  }); // compact to scalar\n\n  if (type === '@id' || type === '@vocab' || expandedProperty === '@graph') {\n    return compacted;\n  }\n\n  return {\n    [api.compactIri({\n      activeCtx,\n      iri: '@id',\n      relativeTo: {\n        vocab: true\n      }\n    })]: compacted\n  };\n};\n/**\n * Removes the @preserve keywords as the last step of the compaction\n * algorithm when it is running on framed output.\n *\n * @param ctx the active context used to compact the input.\n * @param input the framed, compacted output.\n * @param options the compaction options used.\n *\n * @return the resulting output.\n */\n\n\napi.removePreserve = (ctx, input, options) => {\n  // recurse through arrays\n  if (_isArray(input)) {\n    const output = [];\n\n    for (let i = 0; i < input.length; ++i) {\n      const result = api.removePreserve(ctx, input[i], options); // drop nulls from arrays\n\n      if (result !== null) {\n        output.push(result);\n      }\n    }\n\n    input = output;\n  } else if (_isObject(input)) {\n    // remove @preserve\n    if ('@preserve' in input) {\n      if (input['@preserve'] === '@null') {\n        return null;\n      }\n\n      return input['@preserve'];\n    } // skip @values\n\n\n    if (_isValue(input)) {\n      return input;\n    } // recurse through @lists\n\n\n    if (_isList(input)) {\n      input['@list'] = api.removePreserve(ctx, input['@list'], options);\n      return input;\n    } // handle in-memory linked nodes\n\n\n    const idAlias = api.compactIri({\n      activeCtx: ctx,\n      iri: '@id',\n      relativeTo: {\n        vocab: true\n      }\n    });\n\n    if (input.hasOwnProperty(idAlias)) {\n      const id = input[idAlias];\n\n      if (options.link.hasOwnProperty(id)) {\n        const idx = options.link[id].indexOf(input);\n\n        if (idx !== -1) {\n          // already visited\n          return options.link[id][idx];\n        } // prevent circular visitation\n\n\n        options.link[id].push(input);\n      } else {\n        // prevent circular visitation\n        options.link[id] = [input];\n      }\n    } // recurse through properties\n\n\n    const graphAlias = api.compactIri({\n      activeCtx: ctx,\n      iri: '@graph',\n      relativeTo: {\n        vocab: true\n      }\n    });\n\n    for (const prop in input) {\n      // potentially remove the id, if it is an unreference bnode\n      if (prop === idAlias && options.bnodesToClear.includes(input[prop])) {\n        delete input[idAlias];\n        continue;\n      }\n\n      let result = api.removePreserve(ctx, input[prop], options);\n      const container = _getContextValue(ctx, prop, '@container') || [];\n\n      if (options.compactArrays && _isArray(result) && result.length === 1 && container.length === 0 && prop !== graphAlias) {\n        result = result[0];\n      }\n\n      input[prop] = result;\n    }\n  }\n\n  return input;\n};\n/**\n * Picks the preferred compaction term from the given inverse context entry.\n *\n * @param activeCtx the active context.\n * @param iri the IRI to pick the term for.\n * @param value the value to pick the term for.\n * @param containers the preferred containers.\n * @param typeOrLanguage either '@type' or '@language'.\n * @param typeOrLanguageValue the preferred value for '@type' or '@language'.\n *\n * @return the preferred term.\n */\n\n\nfunction _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {\n  if (typeOrLanguageValue === null) {\n    typeOrLanguageValue = '@null';\n  } // preferences for the value of @type or @language\n\n\n  const prefs = []; // determine prefs for @id based on whether or not value compacts to a term\n\n  if ((typeOrLanguageValue === '@id' || typeOrLanguageValue === '@reverse') && _isObject(value) && '@id' in value) {\n    // prefer @reverse first\n    if (typeOrLanguageValue === '@reverse') {\n      prefs.push('@reverse');\n    } // try to compact value to a term\n\n\n    const term = api.compactIri({\n      activeCtx,\n      iri: value['@id'],\n      relativeTo: {\n        vocab: true\n      }\n    });\n\n    if (activeCtx.mappings.has(term) && activeCtx.mappings.get(term) && activeCtx.mappings.get(term)['@id'] === value['@id']) {\n      // prefer @vocab\n      prefs.push.apply(prefs, ['@vocab', '@id']);\n    } else {\n      // prefer @id\n      prefs.push.apply(prefs, ['@id', '@vocab']);\n    }\n  } else {\n    prefs.push(typeOrLanguageValue);\n  }\n\n  prefs.push('@none');\n  const containerMap = activeCtx.inverse[iri];\n\n  for (const container of containers) {\n    // if container not available in the map, continue\n    if (!(container in containerMap)) {\n      continue;\n    }\n\n    const typeOrLanguageValueMap = containerMap[container][typeOrLanguage];\n\n    for (const pref of prefs) {\n      // if type/language option not available in the map, continue\n      if (!(pref in typeOrLanguageValueMap)) {\n        continue;\n      } // select term\n\n\n      return typeOrLanguageValueMap[pref];\n    }\n  }\n\n  return null;\n}\n/**\n * The value of `@nest` in the term definition must either be `@nest`, or a term\n * which resolves to `@nest`.\n *\n * @param activeCtx the active context.\n * @param nestProperty a term in the active context or `@nest`.\n * @param {Object} [options] - processing options.\n */\n\n\nfunction _checkNestProperty(activeCtx, nestProperty, options) {\n  if (_expandIri(activeCtx, nestProperty, {\n    vocab: true\n  }, options) !== '@nest') {\n    throw new JsonLdError('JSON-LD compact error; nested property must have an @nest value ' + 'resolving to @nest.', 'jsonld.SyntaxError', {\n      code: 'invalid @nest value'\n    });\n  }\n}","map":{"version":3,"sources":["/Users/shubhamlal/Desktop/verification/node_modules/jsonld/lib/compact.js"],"names":["JsonLdError","require","isArray","_isArray","isObject","_isObject","isString","_isString","isUndefined","_isUndefined","isList","_isList","isValue","_isValue","isGraph","_isGraph","isSimpleGraph","_isSimpleGraph","isSubjectReference","_isSubjectReference","expandIri","_expandIri","getContextValue","_getContextValue","isKeyword","_isKeyword","process","_processContext","processingMode","_processingMode","removeBase","_removeBase","addValue","_addValue","asArray","_asArray","compareShortestLeast","_compareShortestLeast","api","module","exports","compact","activeCtx","activeProperty","element","options","compactionMap","undefined","rval","i","length","compacted","unmappedValue","parent","index","push","compactArrays","container","ctx","localCtx","propagate","overrideProtected","link","hasOwnProperty","linked","expanded","compactValue","value","includes","insideReverse","inputCtx","revertToPreviousContext","propertyScopedCtx","types","Array","from","sort","typeContext","type","compactedType","compactIri","iri","relativeTo","vocab","keys","Object","expandedProperty","expandedValue","compactedValue","map","expandedIri","alias","typeAsSet","propertyIsArray","compactedProperty","mappings","has","get","reverse","useArray","itemActiveProperty","nestProperty","nestResult","_checkNestProperty","expandedItem","inner","compactedItem","valueIsArray","allowDuplicate","mapObject","key","indexKey","containerKey","others","idKey","typeKey","isPropertyTermScoped","previousContext","inverseCtx","getInverse","defaultLanguage","containers","typeOrLanguage","typeOrLanguageValue","list","commonLanguage","commonType","item","itemLanguage","itemType","term","_selectTerm","indexOf","suffix","substr","choice","partialMatches","iriMap","fastCurieMap","maxPartialLength","entry","terms","curie","isUsableCurie","_prefix","td","startsWith","code","context","language","preserveIndex","keyCount","isValueOnlyKey","hasDefaultLanguage","isValueString","hasNullMapping","removePreserve","input","output","result","idAlias","id","idx","graphAlias","prop","bnodesToClear","prefs","apply","containerMap","inverse","typeOrLanguageValueMap","pref"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst JsonLdError = require('./JsonLdError');\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = require('./types');\n\nconst {\n  isList: _isList,\n  isValue: _isValue,\n  isGraph: _isGraph,\n  isSimpleGraph: _isSimpleGraph,\n  isSubjectReference: _isSubjectReference\n} = require('./graphTypes');\n\nconst {\n  expandIri: _expandIri,\n  getContextValue: _getContextValue,\n  isKeyword: _isKeyword,\n  process: _processContext,\n  processingMode: _processingMode\n} = require('./context');\n\nconst {\n  removeBase: _removeBase\n} = require('./url');\n\nconst {\n  addValue: _addValue,\n  asArray: _asArray,\n  compareShortestLeast: _compareShortestLeast\n} = require('./util');\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Recursively compacts an element using the given active context. All values\n * must be in expanded form before this method is called.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the compacted property associated with the element\n *          to compact, null for none.\n * @param element the element to compact.\n * @param options the compaction options.\n * @param compactionMap the compaction map to use.\n *\n * @return a promise that resolves to the compacted value.\n */\napi.compact = async ({\n  activeCtx,\n  activeProperty = null,\n  element,\n  options = {},\n  compactionMap = () => undefined\n}) => {\n  // recursively compact array\n  if(_isArray(element)) {\n    let rval = [];\n    for(let i = 0; i < element.length; ++i) {\n      // compact, dropping any null values unless custom mapped\n      let compacted = await api.compact({\n        activeCtx,\n        activeProperty,\n        element: element[i],\n        options,\n        compactionMap\n      });\n      if(compacted === null) {\n        compacted = await compactionMap({\n          unmappedValue: element[i],\n          activeCtx,\n          activeProperty,\n          parent: element,\n          index: i,\n          options\n        });\n        if(compacted === undefined) {\n          continue;\n        }\n      }\n      rval.push(compacted);\n    }\n    if(options.compactArrays && rval.length === 1) {\n      // use single element if no container is specified\n      const container = _getContextValue(\n        activeCtx, activeProperty, '@container') || [];\n      if(container.length === 0) {\n        rval = rval[0];\n      }\n    }\n    return rval;\n  }\n\n  // use any scoped context on activeProperty\n  const ctx = _getContextValue(activeCtx, activeProperty, '@context');\n  if(!_isUndefined(ctx)) {\n    activeCtx = await _processContext({\n      activeCtx,\n      localCtx: ctx,\n      propagate: true,\n      overrideProtected: true,\n      options\n    });\n  }\n\n  // recursively compact object\n  if(_isObject(element)) {\n    if(options.link && '@id' in element &&\n      options.link.hasOwnProperty(element['@id'])) {\n      // check for a linked element to reuse\n      const linked = options.link[element['@id']];\n      for(let i = 0; i < linked.length; ++i) {\n        if(linked[i].expanded === element) {\n          return linked[i].compacted;\n        }\n      }\n    }\n\n    // do value compaction on @values and subject references\n    if(_isValue(element) || _isSubjectReference(element)) {\n      const rval =\n        api.compactValue({activeCtx, activeProperty, value: element, options});\n      if(options.link && _isSubjectReference(element)) {\n        // store linked element\n        if(!(options.link.hasOwnProperty(element['@id']))) {\n          options.link[element['@id']] = [];\n        }\n        options.link[element['@id']].push({expanded: element, compacted: rval});\n      }\n      return rval;\n    }\n\n    // if expanded property is @list and we're contained within a list\n    // container, recursively compact this item to an array\n    if(_isList(element)) {\n      const container = _getContextValue(\n        activeCtx, activeProperty, '@container') || [];\n      if(container.includes('@list')) {\n        return api.compact({\n          activeCtx,\n          activeProperty,\n          element: element['@list'],\n          options,\n          compactionMap\n        });\n      }\n    }\n\n    // FIXME: avoid misuse of active property as an expanded property?\n    const insideReverse = (activeProperty === '@reverse');\n\n    const rval = {};\n\n    // original context before applying property-scoped and local contexts\n    const inputCtx = activeCtx;\n\n    // revert to previous context, if there is one,\n    // and element is not a value object or a node reference\n    if(!_isValue(element) && !_isSubjectReference(element)) {\n      activeCtx = activeCtx.revertToPreviousContext();\n    }\n\n    // apply property-scoped context after reverting term-scoped context\n    const propertyScopedCtx =\n      _getContextValue(inputCtx, activeProperty, '@context');\n    if(!_isUndefined(propertyScopedCtx)) {\n      activeCtx = await _processContext({\n        activeCtx,\n        localCtx: propertyScopedCtx,\n        propagate: true,\n        overrideProtected: true,\n        options\n      });\n    }\n\n    if(options.link && '@id' in element) {\n      // store linked element\n      if(!options.link.hasOwnProperty(element['@id'])) {\n        options.link[element['@id']] = [];\n      }\n      options.link[element['@id']].push({expanded: element, compacted: rval});\n    }\n\n    // apply any context defined on an alias of @type\n    // if key is @type and any compacted value is a term having a local\n    // context, overlay that context\n    let types = element['@type'] || [];\n    if(types.length > 1) {\n      types = Array.from(types).sort();\n    }\n    // find all type-scoped contexts based on current context, prior to\n    // updating it\n    const typeContext = activeCtx;\n    for(const type of types) {\n      const compactedType = api.compactIri(\n        {activeCtx: typeContext, iri: type, relativeTo: {vocab: true}});\n\n      // Use any type-scoped context defined on this value\n      const ctx = _getContextValue(inputCtx, compactedType, '@context');\n      if(!_isUndefined(ctx)) {\n        activeCtx = await _processContext({\n          activeCtx,\n          localCtx: ctx,\n          options,\n          propagate: false\n        });\n      }\n    }\n\n    // process element keys in order\n    const keys = Object.keys(element).sort();\n    for(const expandedProperty of keys) {\n      const expandedValue = element[expandedProperty];\n\n      // compact @id\n      if(expandedProperty === '@id') {\n        let compactedValue = _asArray(expandedValue).map(\n          expandedIri => api.compactIri({\n            activeCtx,\n            iri: expandedIri,\n            relativeTo: {vocab: false}\n          }));\n        if(compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri(\n          {activeCtx, iri: '@id', relativeTo: {vocab: true}});\n\n        rval[alias] = compactedValue;\n        continue;\n      }\n\n      // compact @type(s)\n      if(expandedProperty === '@type') {\n        // resolve type values against previous context\n        let compactedValue = _asArray(expandedValue).map(\n          expandedIri => api.compactIri({\n            activeCtx: inputCtx,\n            iri: expandedIri,\n            relativeTo: {vocab: true}\n          }));\n        if(compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri(\n          {activeCtx, iri: '@type', relativeTo: {vocab: true}});\n        const container = _getContextValue(\n          activeCtx, alias, '@container') || [];\n\n        // treat as array for @type if @container includes @set\n        const typeAsSet =\n          container.includes('@set') &&\n          _processingMode(activeCtx, 1.1);\n        const isArray =\n          typeAsSet || (_isArray(compactedValue) && expandedValue.length === 0);\n        _addValue(rval, alias, compactedValue, {propertyIsArray: isArray});\n        continue;\n      }\n\n      // handle @reverse\n      if(expandedProperty === '@reverse') {\n        // recursively compact expanded value\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty: '@reverse',\n          element: expandedValue,\n          options,\n          compactionMap\n        });\n\n        // handle double-reversed properties\n        for(const compactedProperty in compactedValue) {\n          if(activeCtx.mappings.has(compactedProperty) &&\n            activeCtx.mappings.get(compactedProperty).reverse) {\n            const value = compactedValue[compactedProperty];\n            const container = _getContextValue(\n              activeCtx, compactedProperty, '@container') || [];\n            const useArray = (\n              container.includes('@set') || !options.compactArrays);\n            _addValue(\n              rval, compactedProperty, value, {propertyIsArray: useArray});\n            delete compactedValue[compactedProperty];\n          }\n        }\n\n        if(Object.keys(compactedValue).length > 0) {\n          // use keyword alias and add value\n          const alias = api.compactIri({\n            activeCtx,\n            iri: expandedProperty,\n            relativeTo: {vocab: true}\n          });\n          _addValue(rval, alias, compactedValue);\n        }\n\n        continue;\n      }\n\n      if(expandedProperty === '@preserve') {\n        // compact using activeProperty\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty,\n          element: expandedValue,\n          options,\n          compactionMap\n        });\n\n        if(!(_isArray(compactedValue) && compactedValue.length === 0)) {\n          _addValue(rval, expandedProperty, compactedValue);\n        }\n        continue;\n      }\n\n      // handle @index property\n      if(expandedProperty === '@index') {\n        // drop @index if inside an @index container\n        const container = _getContextValue(\n          activeCtx, activeProperty, '@container') || [];\n        if(container.includes('@index')) {\n          continue;\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {vocab: true}\n        });\n        _addValue(rval, alias, expandedValue);\n        continue;\n      }\n\n      // skip array processing for keywords that aren't @graph or @list\n      if(expandedProperty !== '@graph' && expandedProperty !== '@list' &&\n        _isKeyword(expandedProperty)) {\n        // use keyword alias and add value as is\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {vocab: true}\n        });\n        _addValue(rval, alias, expandedValue);\n        continue;\n      }\n\n      // Note: expanded value must be an array due to expansion algorithm.\n      if(!_isArray(expandedValue)) {\n        throw new JsonLdError(\n          'JSON-LD expansion error; expanded value must be an array.',\n          'jsonld.SyntaxError');\n      }\n\n      // preserve empty arrays\n      if(expandedValue.length === 0) {\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedValue,\n          relativeTo: {vocab: true},\n          reverse: insideReverse\n        });\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ?\n          activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n        if(nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n          if(!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n          nestResult = rval[nestProperty];\n        }\n        _addValue(\n          nestResult, itemActiveProperty, expandedValue, {\n            propertyIsArray: true\n          });\n      }\n\n      // recusively process array values\n      for(const expandedItem of expandedValue) {\n        // compact property and get container type\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedItem,\n          relativeTo: {vocab: true},\n          reverse: insideReverse\n        });\n\n        // if itemActiveProperty is a @nest property, add values to nestResult,\n        // otherwise rval\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ?\n          activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n        if(nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n          if(!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n          nestResult = rval[nestProperty];\n        }\n\n        const container = _getContextValue(\n          activeCtx, itemActiveProperty, '@container') || [];\n\n        // get simple @graph or @list value if appropriate\n        const isGraph = _isGraph(expandedItem);\n        const isList = _isList(expandedItem);\n        let inner;\n        if(isList) {\n          inner = expandedItem['@list'];\n        } else if(isGraph) {\n          inner = expandedItem['@graph'];\n        }\n\n        // recursively compact expanded item\n        let compactedItem = await api.compact({\n          activeCtx,\n          activeProperty: itemActiveProperty,\n          element: (isList || isGraph) ? inner : expandedItem,\n          options,\n          compactionMap\n        });\n\n        // handle @list\n        if(isList) {\n          // ensure @list value is an array\n          if(!_isArray(compactedItem)) {\n            compactedItem = [compactedItem];\n          }\n\n          if(!container.includes('@list')) {\n            // wrap using @list alias\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@list',\n                relativeTo: {vocab: true}\n              })]: compactedItem\n            };\n\n            // include @index from expanded @list, if any\n            if('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@index'];\n            }\n          } else {\n            _addValue(nestResult, itemActiveProperty, compactedItem, {\n              valueIsArray: true,\n              allowDuplicate: true\n            });\n            continue;\n          }\n        }\n\n        // Graph object compaction cases\n        if(isGraph) {\n          if(container.includes('@graph') && (container.includes('@id') ||\n            container.includes('@index') && _isSimpleGraph(expandedItem))) {\n            // get or create the map object\n            let mapObject;\n            if(nestResult.hasOwnProperty(itemActiveProperty)) {\n              mapObject = nestResult[itemActiveProperty];\n            } else {\n              nestResult[itemActiveProperty] = mapObject = {};\n            }\n\n            // index on @id or @index or alias of @none\n            const key = (container.includes('@id') ?\n              expandedItem['@id'] : expandedItem['@index']) ||\n              api.compactIri({activeCtx, iri: '@none', vocab: true});\n            // add compactedItem to map, using value of `@id` or a new blank\n            // node identifier\n\n            _addValue(\n              mapObject, key, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          } else if(container.includes('@graph') &&\n            _isSimpleGraph(expandedItem)) {\n            // container includes @graph but not @id or @index and value is a\n            // simple graph object add compact value\n            // if compactedItem contains multiple values, it is wrapped in\n            // `@included`\n            if(_isArray(compactedItem) && compactedItem.length > 1) {\n              compactedItem = {'@included': compactedItem};\n            }\n            _addValue(\n              nestResult, itemActiveProperty, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          } else {\n            // wrap using @graph alias, remove array if only one item and\n            // compactArrays not set\n            if(_isArray(compactedItem) && compactedItem.length === 1 &&\n              options.compactArrays) {\n              compactedItem = compactedItem[0];\n            }\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@graph',\n                relativeTo: {vocab: true}\n              })]: compactedItem\n            };\n\n            // include @id from expanded graph, if any\n            if('@id' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@id',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@id'];\n            }\n\n            // include @index from expanded graph, if any\n            if('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@index'];\n            }\n            _addValue(\n              nestResult, itemActiveProperty, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          }\n        } else if(container.includes('@language') ||\n          container.includes('@index') || container.includes('@id') ||\n          container.includes('@type')) {\n          // handle language and index maps\n          // get or create the map object\n          let mapObject;\n          if(nestResult.hasOwnProperty(itemActiveProperty)) {\n            mapObject = nestResult[itemActiveProperty];\n          } else {\n            nestResult[itemActiveProperty] = mapObject = {};\n          }\n\n          let key;\n          if(container.includes('@language')) {\n          // if container is a language map, simplify compacted value to\n          // a simple string\n            if(_isValue(compactedItem)) {\n              compactedItem = compactedItem['@value'];\n            }\n            key = expandedItem['@language'];\n          } else if(container.includes('@index')) {\n            const indexKey = _getContextValue(\n              activeCtx, itemActiveProperty, '@index') || '@index';\n            const containerKey = api.compactIri(\n              {activeCtx, iri: indexKey, vocab: true});\n            if(indexKey === '@index') {\n              key = expandedItem['@index'];\n              delete compactedItem[containerKey];\n            } else {\n              let others;\n              [key, ...others] = _asArray(compactedItem[indexKey] || []);\n              if(!_isString(key)) {\n                // Will use @none if it isn't a string.\n                key = null;\n              } else {\n                switch(others.length) {\n                  case 0:\n                    delete compactedItem[indexKey];\n                    break;\n                  case 1:\n                    compactedItem[indexKey] = others[0];\n                    break;\n                  default:\n                    compactedItem[indexKey] = others;\n                    break;\n                }\n              }\n            }\n          } else if(container.includes('@id')) {\n            const idKey = api.compactIri({activeCtx, iri: '@id', vocab: true});\n            key = compactedItem[idKey];\n            delete compactedItem[idKey];\n          } else if(container.includes('@type')) {\n            const typeKey = api.compactIri({\n              activeCtx,\n              iri: '@type',\n              vocab: true\n            });\n            let types;\n            [key, ...types] = _asArray(compactedItem[typeKey] || []);\n            switch(types.length) {\n              case 0:\n                delete compactedItem[typeKey];\n                break;\n              case 1:\n                compactedItem[typeKey] = types[0];\n                break;\n              default:\n                compactedItem[typeKey] = types;\n                break;\n            }\n\n            // If compactedItem contains a single entry\n            // whose key maps to @id, recompact without @type\n            if(Object.keys(compactedItem).length === 1 &&\n              '@id' in expandedItem) {\n              compactedItem = await api.compact({\n                activeCtx,\n                activeProperty: itemActiveProperty,\n                element: {'@id': expandedItem['@id']},\n                options,\n                compactionMap\n              });\n            }\n          }\n\n          // if compacting this value which has no key, index on @none\n          if(!key) {\n            key = api.compactIri({activeCtx, iri: '@none', vocab: true});\n          }\n          // add compact value to map object using key from expanded value\n          // based on the container type\n          _addValue(\n            mapObject, key, compactedItem, {\n              propertyIsArray: container.includes('@set')\n            });\n        } else {\n          // use an array if: compactArrays flag is false,\n          // @container is @set or @list , value is an empty\n          // array, or key is @graph\n          const isArray = (!options.compactArrays ||\n            container.includes('@set') || container.includes('@list') ||\n            (_isArray(compactedItem) && compactedItem.length === 0) ||\n            expandedProperty === '@list' || expandedProperty === '@graph');\n\n          // add compact value\n          _addValue(\n            nestResult, itemActiveProperty, compactedItem,\n            {propertyIsArray: isArray});\n        }\n      }\n    }\n\n    return rval;\n  }\n\n  // only primitives remain which are already compact\n  return element;\n};\n\n/**\n * Compacts an IRI or keyword into a term or prefix if it can be. If the\n * IRI has an associated value it may be passed.\n *\n * @param activeCtx the active context to use.\n * @param iri the IRI to compact.\n * @param value the value to check or null.\n * @param relativeTo options for how to compact IRIs:\n *          vocab: true to split after @vocab, false not to.\n * @param reverse true if a reverse property is being compacted, false if not.\n *\n * @return the compacted term, prefix, keyword alias, or the original IRI.\n */\napi.compactIri = ({\n  activeCtx,\n  iri,\n  value = null,\n  relativeTo = {vocab: false},\n  reverse = false\n}) => {\n  // can't compact null\n  if(iri === null) {\n    return iri;\n  }\n\n  // if context is from a property term scoped context composed with a\n  // type-scoped context, then use the previous context instead\n  if(activeCtx.isPropertyTermScoped && activeCtx.previousContext) {\n    activeCtx = activeCtx.previousContext;\n  }\n\n  const inverseCtx = activeCtx.getInverse();\n\n  // if term is a keyword, it may be compacted to a simple alias\n  if(_isKeyword(iri) &&\n    iri in inverseCtx &&\n    '@none' in inverseCtx[iri] &&\n    '@type' in inverseCtx[iri]['@none'] &&\n    '@none' in inverseCtx[iri]['@none']['@type']) {\n    return inverseCtx[iri]['@none']['@type']['@none'];\n  }\n\n  // use inverse context to pick a term if iri is relative to vocab\n  if(relativeTo.vocab && iri in inverseCtx) {\n    const defaultLanguage = activeCtx['@language'] || '@none';\n\n    // prefer @index if available in value\n    const containers = [];\n    if(_isObject(value) && '@index' in value && !('@graph' in value)) {\n      containers.push('@index', '@index@set');\n    }\n\n    // if value is a preserve object, use its value\n    if(_isObject(value) && '@preserve' in value) {\n      value = value['@preserve'][0];\n    }\n\n    // prefer most specific container including @graph, prefering @set\n    // variations\n    if(_isGraph(value)) {\n      // favor indexmap if the graph is indexed\n      if('@index' in value) {\n        containers.push(\n          '@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // favor idmap if the graph is has an @id\n      if('@id' in value) {\n        containers.push(\n          '@graph@id', '@graph@id@set');\n      }\n      containers.push('@graph', '@graph@set', '@set');\n      // allow indexmap if the graph is not indexed\n      if(!('@index' in value)) {\n        containers.push(\n          '@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // allow idmap if the graph does not have an @id\n      if(!('@id' in value)) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n    } else if(_isObject(value) && !_isValue(value)) {\n      containers.push('@id', '@id@set', '@type', '@set@type');\n    }\n\n    // defaults for term selection based on type/language\n    let typeOrLanguage = '@language';\n    let typeOrLanguageValue = '@null';\n\n    if(reverse) {\n      typeOrLanguage = '@type';\n      typeOrLanguageValue = '@reverse';\n      containers.push('@set');\n    } else if(_isList(value)) {\n      // choose the most specific term that works for all elements in @list\n      // only select @list containers if @index is NOT in value\n      if(!('@index' in value)) {\n        containers.push('@list');\n      }\n      const list = value['@list'];\n      if(list.length === 0) {\n        // any empty list can be matched against any term that uses the\n        // @list container regardless of @type or @language\n        typeOrLanguage = '@any';\n        typeOrLanguageValue = '@none';\n      } else {\n        let commonLanguage = (list.length === 0) ? defaultLanguage : null;\n        let commonType = null;\n        for(let i = 0; i < list.length; ++i) {\n          const item = list[i];\n          let itemLanguage = '@none';\n          let itemType = '@none';\n          if(_isValue(item)) {\n            if('@language' in item) {\n              itemLanguage = item['@language'];\n            } else if('@type' in item) {\n              itemType = item['@type'];\n            } else {\n              // plain literal\n              itemLanguage = '@null';\n            }\n          } else {\n            itemType = '@id';\n          }\n          if(commonLanguage === null) {\n            commonLanguage = itemLanguage;\n          } else if(itemLanguage !== commonLanguage && _isValue(item)) {\n            commonLanguage = '@none';\n          }\n          if(commonType === null) {\n            commonType = itemType;\n          } else if(itemType !== commonType) {\n            commonType = '@none';\n          }\n          // there are different languages and types in the list, so choose\n          // the most generic term, no need to keep iterating the list\n          if(commonLanguage === '@none' && commonType === '@none') {\n            break;\n          }\n        }\n        commonLanguage = commonLanguage || '@none';\n        commonType = commonType || '@none';\n        if(commonType !== '@none') {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = commonType;\n        } else {\n          typeOrLanguageValue = commonLanguage;\n        }\n      }\n    } else {\n      if(_isValue(value)) {\n        if('@language' in value && !('@index' in value)) {\n          containers.push('@language', '@language@set');\n          typeOrLanguageValue = value['@language'];\n        } else if('@type' in value) {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = value['@type'];\n        }\n      } else {\n        typeOrLanguage = '@type';\n        typeOrLanguageValue = '@id';\n      }\n      containers.push('@set');\n    }\n\n    // do term selection\n    containers.push('@none');\n\n    // an index map can be used to index values using @none, so add as a low\n    // priority\n    if(_isObject(value) && !('@index' in value)) {\n      // allow indexing even if no @index present\n      containers.push('@index', '@index@set');\n    }\n\n    // values without type or language can use @language map\n    if(_isValue(value) && Object.keys(value).length === 1) {\n      // allow indexing even if no @index present\n      containers.push('@language', '@language@set');\n    }\n\n    const term = _selectTerm(\n      activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);\n    if(term !== null) {\n      return term;\n    }\n  }\n\n  // no term match, use @vocab if available\n  if(relativeTo.vocab) {\n    if('@vocab' in activeCtx) {\n      // determine if vocab is a prefix of the iri\n      const vocab = activeCtx['@vocab'];\n      if(iri.indexOf(vocab) === 0 && iri !== vocab) {\n        // use suffix as relative iri if it is not a term in the active context\n        const suffix = iri.substr(vocab.length);\n        if(!activeCtx.mappings.has(suffix)) {\n          return suffix;\n        }\n      }\n    }\n  }\n\n  // no term or @vocab match, check for possible CURIEs\n  let choice = null;\n  // TODO: make FastCurieMap a class with a method to do this lookup\n  const partialMatches = [];\n  let iriMap = activeCtx.fastCurieMap;\n  // check for partial matches of against `iri`, which means look until\n  // iri.length - 1, not full length\n  const maxPartialLength = iri.length - 1;\n  for(let i = 0; i < maxPartialLength && iri[i] in iriMap; ++i) {\n    iriMap = iriMap[iri[i]];\n    if('' in iriMap) {\n      partialMatches.push(iriMap[''][0]);\n    }\n  }\n  // check partial matches in reverse order to prefer longest ones first\n  for(let i = partialMatches.length - 1; i >= 0; --i) {\n    const entry = partialMatches[i];\n    const terms = entry.terms;\n    for(const term of terms) {\n      // a CURIE is usable if:\n      // 1. it has no mapping, OR\n      // 2. value is null, which means we're not compacting an @value, AND\n      //   the mapping matches the IRI\n      const curie = term + ':' + iri.substr(entry.iri.length);\n      const isUsableCurie = (activeCtx.mappings.get(term)._prefix &&\n        (!activeCtx.mappings.has(curie) ||\n        (value === null && activeCtx.mappings.get(curie)['@id'] === iri)));\n\n      // select curie if it is shorter or the same length but lexicographically\n      // less than the current choice\n      if(isUsableCurie && (choice === null ||\n        _compareShortestLeast(curie, choice) < 0)) {\n        choice = curie;\n      }\n    }\n  }\n\n  // return chosen curie\n  if(choice !== null) {\n    return choice;\n  }\n\n  // If iri could be confused with a compact IRI using a term in this context,\n  // signal an error\n  for(const [term, td] of activeCtx.mappings) {\n    if(td && td._prefix && iri.startsWith(term + ':')) {\n      throw new JsonLdError(\n        `Absolute IRI \"${iri}\" confused with prefix \"${term}\".`,\n        'jsonld.SyntaxError',\n        {code: 'IRI confused with prefix', context: activeCtx});\n    }\n  }\n\n  // compact IRI relative to base\n  if(!relativeTo.vocab) {\n    return _removeBase(activeCtx['@base'], iri);\n  }\n\n  // return IRI as is\n  return iri;\n};\n\n/**\n * Performs value compaction on an object with '@value' or '@id' as the only\n * property.\n *\n * @param activeCtx the active context.\n * @param activeProperty the active property that points to the value.\n * @param value the value to compact.\n * @param {Object} [options] - processing options.\n *\n * @return the compaction result.\n */\napi.compactValue = ({activeCtx, activeProperty, value, options}) => {\n  // value is a @value\n  if(_isValue(value)) {\n    // get context rules\n    const type = _getContextValue(activeCtx, activeProperty, '@type');\n    const language = _getContextValue(activeCtx, activeProperty, '@language');\n    const container =\n      _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n    // whether or not the value has an @index that must be preserved\n    const preserveIndex = '@index' in value && !container.includes('@index');\n\n    // if there's no @index to preserve ...\n    if(!preserveIndex && type !== '@none') {\n      // matching @type or @language specified in context, compact value\n      if(value['@type'] === type || value['@language'] === language) {\n        return value['@value'];\n      }\n    }\n\n    // return just the value of @value if all are true:\n    // 1. @value is the only key or @index isn't being preserved\n    // 2. there is no default language or @value is not a string or\n    //   the key has a mapping with a null @language\n    const keyCount = Object.keys(value).length;\n    const isValueOnlyKey = (keyCount === 1 ||\n      (keyCount === 2 && '@index' in value && !preserveIndex));\n    const hasDefaultLanguage = ('@language' in activeCtx);\n    const isValueString = _isString(value['@value']);\n    const hasNullMapping = (activeCtx.mappings.has(activeProperty) &&\n      activeCtx.mappings.get(activeProperty)['@language'] === null);\n    if(isValueOnlyKey &&\n      type !== '@none' &&\n      (!hasDefaultLanguage || !isValueString || hasNullMapping)) {\n      return value['@value'];\n    }\n\n    const rval = {};\n\n    // preserve @index\n    if(preserveIndex) {\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@index',\n        relativeTo: {vocab: true}\n      })] = value['@index'];\n    }\n\n    if('@type' in value) {\n      // compact @type IRI\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@type',\n        relativeTo: {vocab: true}\n      })] = api.compactIri(\n        {activeCtx, iri: value['@type'], relativeTo: {vocab: true}});\n    } else if('@language' in value) {\n      // alias @language\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@language',\n        relativeTo: {vocab: true}\n      })] = value['@language'];\n    }\n\n    // alias @value\n    rval[api.compactIri({\n      activeCtx,\n      iri: '@value',\n      relativeTo: {vocab: true}\n    })] = value['@value'];\n\n    return rval;\n  }\n\n  // value is a subject reference\n  const expandedProperty = _expandIri(activeCtx, activeProperty, {vocab: true},\n    options);\n  const type = _getContextValue(activeCtx, activeProperty, '@type');\n  const compacted = api.compactIri(\n    {activeCtx, iri: value['@id'], relativeTo: {vocab: type === '@vocab'}});\n\n  // compact to scalar\n  if(type === '@id' || type === '@vocab' || expandedProperty === '@graph') {\n    return compacted;\n  }\n\n  return {\n    [api.compactIri({\n      activeCtx,\n      iri: '@id',\n      relativeTo: {vocab: true}\n    })]: compacted\n  };\n};\n\n/**\n * Removes the @preserve keywords as the last step of the compaction\n * algorithm when it is running on framed output.\n *\n * @param ctx the active context used to compact the input.\n * @param input the framed, compacted output.\n * @param options the compaction options used.\n *\n * @return the resulting output.\n */\napi.removePreserve = (ctx, input, options) => {\n  // recurse through arrays\n  if(_isArray(input)) {\n    const output = [];\n    for(let i = 0; i < input.length; ++i) {\n      const result = api.removePreserve(ctx, input[i], options);\n      // drop nulls from arrays\n      if(result !== null) {\n        output.push(result);\n      }\n    }\n    input = output;\n  } else if(_isObject(input)) {\n    // remove @preserve\n    if('@preserve' in input) {\n      if(input['@preserve'] === '@null') {\n        return null;\n      }\n      return input['@preserve'];\n    }\n\n    // skip @values\n    if(_isValue(input)) {\n      return input;\n    }\n\n    // recurse through @lists\n    if(_isList(input)) {\n      input['@list'] = api.removePreserve(ctx, input['@list'], options);\n      return input;\n    }\n\n    // handle in-memory linked nodes\n    const idAlias = api.compactIri({\n      activeCtx: ctx,\n      iri: '@id',\n      relativeTo: {vocab: true}\n    });\n    if(input.hasOwnProperty(idAlias)) {\n      const id = input[idAlias];\n      if(options.link.hasOwnProperty(id)) {\n        const idx = options.link[id].indexOf(input);\n        if(idx !== -1) {\n          // already visited\n          return options.link[id][idx];\n        }\n        // prevent circular visitation\n        options.link[id].push(input);\n      } else {\n        // prevent circular visitation\n        options.link[id] = [input];\n      }\n    }\n\n    // recurse through properties\n    const graphAlias = api.compactIri({\n      activeCtx: ctx,\n      iri: '@graph',\n      relativeTo: {vocab: true}\n    });\n    for(const prop in input) {\n      // potentially remove the id, if it is an unreference bnode\n      if(prop === idAlias && options.bnodesToClear.includes(input[prop])) {\n        delete input[idAlias];\n        continue;\n      }\n\n      let result = api.removePreserve(ctx, input[prop], options);\n      const container = _getContextValue(ctx, prop, '@container') || [];\n      if(options.compactArrays && _isArray(result) && result.length === 1 &&\n        container.length === 0 && prop !== graphAlias) {\n        result = result[0];\n      }\n      input[prop] = result;\n    }\n  }\n  return input;\n};\n\n/**\n * Picks the preferred compaction term from the given inverse context entry.\n *\n * @param activeCtx the active context.\n * @param iri the IRI to pick the term for.\n * @param value the value to pick the term for.\n * @param containers the preferred containers.\n * @param typeOrLanguage either '@type' or '@language'.\n * @param typeOrLanguageValue the preferred value for '@type' or '@language'.\n *\n * @return the preferred term.\n */\nfunction _selectTerm(\n  activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {\n  if(typeOrLanguageValue === null) {\n    typeOrLanguageValue = '@null';\n  }\n\n  // preferences for the value of @type or @language\n  const prefs = [];\n\n  // determine prefs for @id based on whether or not value compacts to a term\n  if((typeOrLanguageValue === '@id' || typeOrLanguageValue === '@reverse') &&\n    _isObject(value) && '@id' in value) {\n    // prefer @reverse first\n    if(typeOrLanguageValue === '@reverse') {\n      prefs.push('@reverse');\n    }\n    // try to compact value to a term\n    const term = api.compactIri(\n      {activeCtx, iri: value['@id'], relativeTo: {vocab: true}});\n    if(activeCtx.mappings.has(term) &&\n      activeCtx.mappings.get(term) &&\n      activeCtx.mappings.get(term)['@id'] === value['@id']) {\n      // prefer @vocab\n      prefs.push.apply(prefs, ['@vocab', '@id']);\n    } else {\n      // prefer @id\n      prefs.push.apply(prefs, ['@id', '@vocab']);\n    }\n  } else {\n    prefs.push(typeOrLanguageValue);\n  }\n  prefs.push('@none');\n\n  const containerMap = activeCtx.inverse[iri];\n  for(const container of containers) {\n    // if container not available in the map, continue\n    if(!(container in containerMap)) {\n      continue;\n    }\n\n    const typeOrLanguageValueMap = containerMap[container][typeOrLanguage];\n    for(const pref of prefs) {\n      // if type/language option not available in the map, continue\n      if(!(pref in typeOrLanguageValueMap)) {\n        continue;\n      }\n\n      // select term\n      return typeOrLanguageValueMap[pref];\n    }\n  }\n\n  return null;\n}\n\n/**\n * The value of `@nest` in the term definition must either be `@nest`, or a term\n * which resolves to `@nest`.\n *\n * @param activeCtx the active context.\n * @param nestProperty a term in the active context or `@nest`.\n * @param {Object} [options] - processing options.\n */\nfunction _checkNestProperty(activeCtx, nestProperty, options) {\n  if(_expandIri(activeCtx, nestProperty, {vocab: true}, options) !== '@nest') {\n    throw new JsonLdError(\n      'JSON-LD compact error; nested property must have an @nest value ' +\n      'resolving to @nest.',\n      'jsonld.SyntaxError', {code: 'invalid @nest value'});\n  }\n}\n"]},"metadata":{},"sourceType":"script"}