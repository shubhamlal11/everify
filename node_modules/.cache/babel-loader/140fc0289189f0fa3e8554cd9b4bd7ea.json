{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Image = void 0;\n\nconst CppObject_1 = require(\"./CppObject\");\n\nconst Symbol_1 = require(\"./Symbol\");\n\nconst instance_1 = require(\"./instance\");\n\nclass Image extends CppObject_1.CppObject {\n  static async createFromGrayBuffer(width, height, dataBuf) {\n    let sequence_num = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    const inst = await (0, instance_1.getInstance)();\n    const heap = inst.HEAPU8;\n    const data = new Uint8Array(dataBuf);\n    const len = width * height;\n\n    if (len !== data.byteLength) {\n      throw Error('dataBuf does not match width and height');\n    }\n\n    const buf = inst._malloc(len);\n\n    heap.set(data, buf);\n\n    const ptr = inst._Image_create(width, height, 0x30303859\n    /* Y800 */\n    , buf, len, sequence_num);\n\n    return new this(ptr, inst);\n  }\n\n  static async createFromRGBABuffer(width, height, dataBuf) {\n    let sequence_num = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    const inst = await (0, instance_1.getInstance)();\n    const heap = inst.HEAPU8;\n    const data = new Uint8Array(dataBuf);\n    const len = width * height;\n\n    if (len * 4 !== data.byteLength) {\n      throw Error('dataBuf does not match width and height');\n    }\n\n    const buf = inst._malloc(len);\n\n    for (let i = 0; i < len; ++i) {\n      const r = data[i * 4];\n      const g = data[i * 4 + 1];\n      const b = data[i * 4 + 2];\n      heap[buf + i] = r * 19595 + g * 38469 + b * 7472 >> 16;\n    }\n\n    const ptr = inst._Image_create(width, height, 0x30303859\n    /* Y800 */\n    , buf, len, sequence_num);\n\n    return new this(ptr, inst);\n  }\n\n  destroy() {\n    this.checkAlive();\n\n    this.inst._Image_destory(this.ptr);\n\n    this.ptr = 0;\n  }\n\n  getSymbols() {\n    this.checkAlive();\n\n    const res = this.inst._Image_get_symbols(this.ptr);\n\n    return Symbol_1.Symbol.createSymbolsFromPtr(res, this.inst.HEAPU8.buffer);\n  }\n\n}\n\nexports.Image = Image;","map":{"version":3,"sources":["../src/Image.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Image = void 0;\nconst CppObject_1 = require(\"./CppObject\");\nconst Symbol_1 = require(\"./Symbol\");\nconst instance_1 = require(\"./instance\");\nclass Image extends CppObject_1.CppObject {\n    static async createFromGrayBuffer(width, height, dataBuf, sequence_num = 0) {\n        const inst = await (0, instance_1.getInstance)();\n        const heap = inst.HEAPU8;\n        const data = new Uint8Array(dataBuf);\n        const len = width * height;\n        if (len !== data.byteLength) {\n            throw Error('dataBuf does not match width and height');\n        }\n        const buf = inst._malloc(len);\n        heap.set(data, buf);\n        const ptr = inst._Image_create(width, height, 0x30303859 /* Y800 */, buf, len, sequence_num);\n        return new this(ptr, inst);\n    }\n    static async createFromRGBABuffer(width, height, dataBuf, sequence_num = 0) {\n        const inst = await (0, instance_1.getInstance)();\n        const heap = inst.HEAPU8;\n        const data = new Uint8Array(dataBuf);\n        const len = width * height;\n        if (len * 4 !== data.byteLength) {\n            throw Error('dataBuf does not match width and height');\n        }\n        const buf = inst._malloc(len);\n        for (let i = 0; i < len; ++i) {\n            const r = data[i * 4];\n            const g = data[i * 4 + 1];\n            const b = data[i * 4 + 2];\n            heap[buf + i] = (r * 19595 + g * 38469 + b * 7472) >> 16;\n        }\n        const ptr = inst._Image_create(width, height, 0x30303859 /* Y800 */, buf, len, sequence_num);\n        return new this(ptr, inst);\n    }\n    destroy() {\n        this.checkAlive();\n        this.inst._Image_destory(this.ptr);\n        this.ptr = 0;\n    }\n    getSymbols() {\n        this.checkAlive();\n        const res = this.inst._Image_get_symbols(this.ptr);\n        return Symbol_1.Symbol.createSymbolsFromPtr(res, this.inst.HEAPU8.buffer);\n    }\n}\nexports.Image = Image;\n//# sourceMappingURL=Image.js.map"]},"metadata":{},"sourceType":"script"}