{"ast":null,"code":"/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst constants = require('./constants');\n\nconst jsonld = require('jsonld');\n\nconst {\n  extendContextLoader,\n  strictDocumentLoader\n} = require('./documentLoader');\n\nconst {\n  serializeError\n} = require('serialize-error');\n\nconst strictExpansionMap = require('./expansionMap');\n\nconst PublicKeyProofPurpose = require('./purposes/PublicKeyProofPurpose');\n\nmodule.exports = class ProofSet {\n  /**\n   * Adds a Linked Data proof to a document. If the document contains other\n   * proofs, the new proof will be appended to the existing set of proofs.\n   *\n   * Important note: This method assumes that the term `proof` in the given\n   * document has the same definition as the `https://w3id.org/security/v2`\n   * JSON-LD @context.\n   *\n   * @param document {object|string} Object to be signed, either a string URL\n   *   (resolved via the given `documentLoader`) or a plain object (JSON-LD\n   *   document).\n   * @param options {object} Options hashmap.\n   *\n   * A `suite` option is required:\n   *\n   * @param options.suite {LinkedDataSignature} a signature suite instance\n   *   that will create the proof.\n   *\n   * A `purpose` option is required:\n   *\n   * @param options.purpose {ProofPurpose} a proof purpose instance that will\n   *   augment the proof with information describing its intended purpose.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param [documentLoader] {function} a custom document loader,\n   *   `Promise<RemoteDocument> documentLoader(url)`.\n   * @param [expansionMap] {function} A custom expansion map that is\n   *   passed to the JSON-LD processor; by default a function that will throw\n   *   an error when unmapped properties are detected in the input, use `false`\n   *   to turn this off and allow unmapped properties to be dropped or use a\n   *   custom function.\n   * @param [compactProof] {boolean} `true` instructs this call to compact\n   *   the resulting proof to the same JSON-LD `@context` as the input\n   *   document; this is the default behavior. Setting this flag to `false` can\n   *   be used as an optimization to prevent an unnecessary compaction when the\n   *   caller knows that all used proof terms have the same definition in the\n   *   document's `@context` as the `constants.SECURITY_CONTEXT_URL` `@context`.\n   *\n   * @return {Promise<object>} resolves with the signed document, with\n   *   the signature in the top-level `proof` property.\n   */\n  async add(document) {\n    let {\n      suite,\n      purpose,\n      documentLoader,\n      expansionMap,\n      compactProof = true\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n\n    if (!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n\n    if (suite.legacy) {\n      if (!(purpose instanceof PublicKeyProofPurpose)) {\n        throw new TypeError(`The \"${suite.type}\" suite requires \"options.purpose\" to be ` + 'an instance of \"PublicKeyProofPurpose\".');\n      }\n    }\n\n    if (documentLoader) {\n      documentLoader = extendContextLoader(documentLoader);\n    } else {\n      documentLoader = strictDocumentLoader;\n    }\n\n    if (expansionMap !== false) {\n      expansionMap = strictExpansionMap;\n    }\n\n    if (typeof document === 'string') {\n      // fetch document\n      document = await documentLoader(document);\n    } // preprocess document to prepare to remove existing proofs\n\n\n    let input;\n\n    if (compactProof) {\n      // cannot assume security context terms, so do full compaction\n      input = await jsonld.compact(document, constants.SECURITY_CONTEXT_URL, {\n        documentLoader,\n        expansionMap,\n        compactToRelative: false\n      });\n    } else {\n      // TODO: optimize to modify document in place to maximize optimization\n      // shallow copy document to allow removal of existing proofs\n      input = { ...document\n      };\n    } // save but exclude any existing proof(s)\n\n\n    const proofProperty = suite.legacy ? 'signature' : 'proof'; //const existingProofs = input[proofProperty];\n\n    delete input[proofProperty]; // create the new proof (suites MUST output a proof using the security-v2\n    // `@context`)\n\n    const proof = await suite.createProof({\n      document: input,\n      purpose,\n      documentLoader,\n      expansionMap,\n      compactProof\n    });\n\n    if (compactProof) {\n      // compact proof to match document's context\n      let expandedProof;\n\n      if (suite.legacy) {\n        expandedProof = {\n          [constants.SECURITY_SIGNATURE_URL]: proof\n        };\n      } else {\n        expandedProof = {\n          [constants.SECURITY_PROOF_URL]: {\n            '@graph': proof\n          }\n        };\n      } // account for type-scoped `proof` definition by getting document types\n\n\n      const {\n        types,\n        alias\n      } = await _getTypeInfo({\n        document,\n        documentLoader,\n        expansionMap\n      });\n      expandedProof['@type'] = types;\n      const ctx = jsonld.getValues(document, '@context');\n      const compactProof = await jsonld.compact(expandedProof, ctx, {\n        documentLoader,\n        expansionMap,\n        compactToRelative: false\n      });\n      delete compactProof[alias];\n      delete compactProof['@context']; // add proof to document\n\n      const key = Object.keys(compactProof)[0];\n      jsonld.addValue(document, key, compactProof[key]);\n    } else {\n      // in-place restore any existing proofs\n\n      /*if(existingProofs) {\n        document[proofProperty] = existingProofs;\n      }*/\n      // add new proof\n      delete proof['@context'];\n      jsonld.addValue(document, proofProperty, proof);\n    }\n\n    return document;\n  }\n  /**\n   * Verifies Linked Data proof(s) on a document. The proofs to be verified\n   * must match the given proof purpose.\n   *\n   * Important note: This method assumes that the term `proof` in the given\n   * document has the same definition as the `https://w3id.org/security/v2`\n   * JSON-LD @context.\n   *\n   * @param {object|string} document - Object with one or more proofs to be\n   *   verified, either a string URL (resolved to an object via the given\n   *   `documentLoader`) or a plain object (JSON-LD document).\n   *\n   * @param {LinkedDataSignature|LinkedDataSignature[]} suite -\n   *   Acceptable signature suite instances for verifying the proof(s).\n   *\n   * @param {ProofPurpose} purpose - A proof purpose instance that will\n   *   match proofs to be verified and ensure they were created according to\n   *   the appropriate purpose.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param {function} [documentLoader]  a custom document loader,\n   *   `Promise<RemoteDocument> documentLoader(url)`.\n   * @param {function} [expansionMap] - A custom expansion map that is\n   *   passed to the JSON-LD processor; by default a function that will throw\n   *   an error when unmapped properties are detected in the input, use `false`\n   *   to turn this off and allow unmapped properties to be dropped or use a\n   *   custom function.\n   * @param {boolean} [compactProof=true] - Indicates that this method cannot\n   *   assume that the incoming document has defined all proof terms in the\n   *   same way as the `constants.SECURITY_CONTEXT_URL` JSON-LD `@context`.\n   *   This means that this method must compact any found proofs to this\n   *   context for internal and extension processing; this is the default\n   *   behavior. To override this behavior and optimize away this step because\n   *   the caller knows that the input document's JSON-LD `@context` defines\n   *   the proof terms in the same way, set this flag to `false`.\n   *\n   * @return {Promise<{verified: boolean, results: Array, error: *}>} resolves\n   *   with an object with a `verified`boolean property that is `true` if at\n   *   least one proof matching the given purpose and suite verifies and `false`\n   *   otherwise; a `results` property with an array of detailed results;\n   *   if `false` an `error` property will be present.\n   */\n\n\n  async verify(document) {\n    let {\n      suite,\n      purpose,\n      documentLoader,\n      expansionMap,\n      compactProof = true\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n\n    if (!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n\n    const suites = Array.isArray(suite) ? suite : [suite];\n\n    if (suites.length === 0) {\n      throw new TypeError('At least one suite is required.');\n    }\n\n    const legacy = suites.some(s => s.legacy);\n\n    if (legacy) {\n      if (suites.some(s => !s.legacy)) {\n        throw new Error('Legacy suites may not be combined with current suites.');\n      } else if (!(purpose instanceof PublicKeyProofPurpose)) {\n        throw new TypeError('\"options.purpose\" must be an instance of \"PublicKeyProofPurpose\"' + 'to use a legacy suite.');\n      }\n    }\n\n    if (documentLoader) {\n      documentLoader = extendContextLoader(documentLoader);\n    } else {\n      documentLoader = strictDocumentLoader;\n    }\n\n    if (expansionMap !== false) {\n      expansionMap = strictExpansionMap;\n    }\n\n    try {\n      if (typeof document === 'string') {\n        // fetch document\n        document = await documentLoader(document);\n      } else {\n        // TODO: consider in-place editing to optimize when `compactProof`\n        // is `false`\n        // shallow copy to allow for removal of proof set prior to canonize\n        document = { ...document\n        };\n      } // get proofs from document\n\n\n      const {\n        proofSet,\n        document: doc\n      } = await _getProofs({\n        document,\n        legacy,\n        documentLoader,\n        expansionMap,\n        compactProof\n      });\n      document = doc; // verify proofs\n\n      const results = await _verify({\n        document,\n        suites,\n        proofSet,\n        purpose,\n        documentLoader,\n        expansionMap,\n        compactProof\n      });\n\n      if (results.length === 0) {\n        throw new Error('Could not verify any proofs; no proofs matched the required ' + 'suite and purpose.');\n      } // combine results\n\n\n      const verified = results.some(r => r.verified);\n\n      if (!verified) {\n        const errors = [].concat(...results.filter(r => r.error).map(r => r.error));\n        const result = {\n          verified,\n          results\n        };\n\n        if (errors.length > 0) {\n          result.error = errors;\n        }\n\n        return result;\n      }\n\n      return {\n        verified,\n        results\n      };\n    } catch (error) {\n      _addToJSON(error);\n\n      return {\n        verified: false,\n        error\n      };\n    }\n  }\n\n};\n\nasync function _getProofs(_ref) {\n  let {\n    document,\n    legacy,\n    documentLoader,\n    expansionMap,\n    compactProof\n  } = _ref;\n  // handle document preprocessing to find proofs\n  const proofProperty = legacy ? 'signature' : 'proof';\n  let proofSet;\n\n  if (compactProof) {\n    // if we must compact the proof(s) then we must first compact the input\n    // document to find the proof(s)\n    document = await jsonld.compact(document, constants.SECURITY_CONTEXT_URL, {\n      documentLoader,\n      expansionMap,\n      compactToRelative: false\n    });\n  }\n\n  proofSet = jsonld.getValues(document, proofProperty);\n  delete document[proofProperty];\n\n  if (proofSet.length === 0) {\n    // no possible matches\n    throw new Error('No matching proofs found in the given document.');\n  } // TODO: consider in-place editing to optimize\n  // shallow copy proofs and add SECURITY_CONTEXT_URL\n\n\n  proofSet = proofSet.map(proof => ({\n    '@context': constants.SECURITY_CONTEXT_URL,\n    ...proof\n  }));\n  return {\n    proofSet,\n    document\n  };\n}\n\nasync function _verify(_ref2) {\n  let {\n    document,\n    suites,\n    proofSet,\n    purpose,\n    documentLoader,\n    expansionMap,\n    compactProof\n  } = _ref2;\n  // filter out matching proofs\n  const result = await Promise.all(proofSet.map(proof => purpose.match(proof, {\n    document,\n    documentLoader,\n    expansionMap\n  })));\n  const matches = proofSet.filter((value, index) => result[index]);\n\n  if (matches.length === 0) {\n    // no matches, nothing to verify\n    return [];\n  } // verify each matching proof\n\n\n  return (await Promise.all(matches.map(async proof => {\n    for (const s of suites) {\n      if (await s.matchProof({\n        proof,\n        document,\n        documentLoader,\n        expansionMap\n      })) {\n        return s.verifyProof({\n          proof,\n          document,\n          purpose,\n          documentLoader,\n          expansionMap,\n          compactProof\n        }).catch(error => ({\n          verified: false,\n          error\n        }));\n      }\n    }\n  }))).map((r, i) => {\n    if (!r) {\n      return null;\n    }\n\n    if (r.error) {\n      _addToJSON(r.error);\n    }\n\n    return {\n      proof: matches[i],\n      ...r\n    };\n  }).filter(r => r);\n} // add a `toJSON` method to an error which allows for errors in validation\n// reports to be serialized properly by `JSON.stringify`.\n\n\nfunction _addToJSON(error) {\n  Object.defineProperty(error, 'toJSON', {\n    value: function () {\n      return serializeError(this);\n    },\n    configurable: true,\n    writable: true\n  });\n}\n\nasync function _getTypeInfo(_ref3) {\n  let {\n    document,\n    documentLoader,\n    expansionMap\n  } = _ref3;\n  // determine `@type` alias, if any\n  const ctx = jsonld.getValues(document, '@context');\n  const compacted = await jsonld.compact({\n    '@type': '_:b0'\n  }, ctx, {\n    documentLoader,\n    expansionMap\n  });\n  delete compacted['@context'];\n  const alias = Object.keys(compacted)[0]; // optimize: expand only `@type` and `type` values\n\n  const toExpand = {\n    '@context': ctx\n  };\n  toExpand['@type'] = jsonld.getValues(document, '@type').concat(jsonld.getValues(document, alias));\n  const expanded = (await jsonld.expand(toExpand, {\n    documentLoader,\n    expansionMap\n  }))[0] || {};\n  return {\n    types: jsonld.getValues(expanded, '@type'),\n    alias\n  };\n}","map":{"version":3,"sources":["/Users/shubhamlal/Desktop/verification/node_modules/jsonld-signatures/lib/ProofSet.js"],"names":["constants","require","jsonld","extendContextLoader","strictDocumentLoader","serializeError","strictExpansionMap","PublicKeyProofPurpose","module","exports","ProofSet","add","document","suite","purpose","documentLoader","expansionMap","compactProof","TypeError","legacy","type","input","compact","SECURITY_CONTEXT_URL","compactToRelative","proofProperty","proof","createProof","expandedProof","SECURITY_SIGNATURE_URL","SECURITY_PROOF_URL","types","alias","_getTypeInfo","ctx","getValues","key","Object","keys","addValue","verify","suites","Array","isArray","length","some","s","Error","proofSet","doc","_getProofs","results","_verify","verified","r","errors","concat","filter","error","map","result","_addToJSON","Promise","all","match","matches","value","index","matchProof","verifyProof","catch","i","defineProperty","configurable","writable","compacted","toExpand","expanded","expand"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst constants = require('./constants');\nconst jsonld = require('jsonld');\nconst {extendContextLoader, strictDocumentLoader} = require('./documentLoader');\nconst {serializeError} = require('serialize-error');\nconst strictExpansionMap = require('./expansionMap');\nconst PublicKeyProofPurpose = require('./purposes/PublicKeyProofPurpose');\n\nmodule.exports = class ProofSet {\n  /**\n   * Adds a Linked Data proof to a document. If the document contains other\n   * proofs, the new proof will be appended to the existing set of proofs.\n   *\n   * Important note: This method assumes that the term `proof` in the given\n   * document has the same definition as the `https://w3id.org/security/v2`\n   * JSON-LD @context.\n   *\n   * @param document {object|string} Object to be signed, either a string URL\n   *   (resolved via the given `documentLoader`) or a plain object (JSON-LD\n   *   document).\n   * @param options {object} Options hashmap.\n   *\n   * A `suite` option is required:\n   *\n   * @param options.suite {LinkedDataSignature} a signature suite instance\n   *   that will create the proof.\n   *\n   * A `purpose` option is required:\n   *\n   * @param options.purpose {ProofPurpose} a proof purpose instance that will\n   *   augment the proof with information describing its intended purpose.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param [documentLoader] {function} a custom document loader,\n   *   `Promise<RemoteDocument> documentLoader(url)`.\n   * @param [expansionMap] {function} A custom expansion map that is\n   *   passed to the JSON-LD processor; by default a function that will throw\n   *   an error when unmapped properties are detected in the input, use `false`\n   *   to turn this off and allow unmapped properties to be dropped or use a\n   *   custom function.\n   * @param [compactProof] {boolean} `true` instructs this call to compact\n   *   the resulting proof to the same JSON-LD `@context` as the input\n   *   document; this is the default behavior. Setting this flag to `false` can\n   *   be used as an optimization to prevent an unnecessary compaction when the\n   *   caller knows that all used proof terms have the same definition in the\n   *   document's `@context` as the `constants.SECURITY_CONTEXT_URL` `@context`.\n   *\n   * @return {Promise<object>} resolves with the signed document, with\n   *   the signature in the top-level `proof` property.\n   */\n  async add(document, {\n    suite, purpose, documentLoader, expansionMap,\n    compactProof = true} = {}) {\n    if(!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if(!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n\n    if(suite.legacy) {\n      if(!(purpose instanceof PublicKeyProofPurpose)) {\n        throw new TypeError(\n          `The \"${suite.type}\" suite requires \"options.purpose\" to be ` +\n          'an instance of \"PublicKeyProofPurpose\".');\n      }\n    }\n\n    if(documentLoader) {\n      documentLoader = extendContextLoader(documentLoader);\n    } else {\n      documentLoader = strictDocumentLoader;\n    }\n    if(expansionMap !== false) {\n      expansionMap = strictExpansionMap;\n    }\n\n    if(typeof document === 'string') {\n      // fetch document\n      document = await documentLoader(document);\n    }\n\n    // preprocess document to prepare to remove existing proofs\n    let input;\n    if(compactProof) {\n      // cannot assume security context terms, so do full compaction\n      input = await jsonld.compact(\n        document, constants.SECURITY_CONTEXT_URL,\n        {documentLoader, expansionMap, compactToRelative: false});\n    } else {\n      // TODO: optimize to modify document in place to maximize optimization\n\n      // shallow copy document to allow removal of existing proofs\n      input = {...document};\n    }\n\n    // save but exclude any existing proof(s)\n    const proofProperty = suite.legacy ? 'signature' : 'proof';\n    //const existingProofs = input[proofProperty];\n    delete input[proofProperty];\n\n    // create the new proof (suites MUST output a proof using the security-v2\n    // `@context`)\n    const proof = await suite.createProof({\n      document: input, purpose, documentLoader,\n      expansionMap, compactProof});\n\n    if(compactProof) {\n      // compact proof to match document's context\n      let expandedProof;\n      if(suite.legacy) {\n        expandedProof = {\n          [constants.SECURITY_SIGNATURE_URL]: proof\n        };\n      } else {\n        expandedProof = {\n          [constants.SECURITY_PROOF_URL]: {'@graph': proof}\n        };\n      }\n      // account for type-scoped `proof` definition by getting document types\n      const {types, alias} = await _getTypeInfo(\n        {document, documentLoader, expansionMap});\n      expandedProof['@type'] = types;\n      const ctx = jsonld.getValues(document, '@context');\n      const compactProof = await jsonld.compact(\n        expandedProof, ctx,\n        {documentLoader, expansionMap, compactToRelative: false});\n      delete compactProof[alias];\n      delete compactProof['@context'];\n\n      // add proof to document\n      const key = Object.keys(compactProof)[0];\n      jsonld.addValue(document, key, compactProof[key]);\n    } else {\n      // in-place restore any existing proofs\n      /*if(existingProofs) {\n        document[proofProperty] = existingProofs;\n      }*/\n      // add new proof\n      delete proof['@context'];\n      jsonld.addValue(document, proofProperty, proof);\n    }\n\n    return document;\n  }\n\n  /**\n   * Verifies Linked Data proof(s) on a document. The proofs to be verified\n   * must match the given proof purpose.\n   *\n   * Important note: This method assumes that the term `proof` in the given\n   * document has the same definition as the `https://w3id.org/security/v2`\n   * JSON-LD @context.\n   *\n   * @param {object|string} document - Object with one or more proofs to be\n   *   verified, either a string URL (resolved to an object via the given\n   *   `documentLoader`) or a plain object (JSON-LD document).\n   *\n   * @param {LinkedDataSignature|LinkedDataSignature[]} suite -\n   *   Acceptable signature suite instances for verifying the proof(s).\n   *\n   * @param {ProofPurpose} purpose - A proof purpose instance that will\n   *   match proofs to be verified and ensure they were created according to\n   *   the appropriate purpose.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param {function} [documentLoader]  a custom document loader,\n   *   `Promise<RemoteDocument> documentLoader(url)`.\n   * @param {function} [expansionMap] - A custom expansion map that is\n   *   passed to the JSON-LD processor; by default a function that will throw\n   *   an error when unmapped properties are detected in the input, use `false`\n   *   to turn this off and allow unmapped properties to be dropped or use a\n   *   custom function.\n   * @param {boolean} [compactProof=true] - Indicates that this method cannot\n   *   assume that the incoming document has defined all proof terms in the\n   *   same way as the `constants.SECURITY_CONTEXT_URL` JSON-LD `@context`.\n   *   This means that this method must compact any found proofs to this\n   *   context for internal and extension processing; this is the default\n   *   behavior. To override this behavior and optimize away this step because\n   *   the caller knows that the input document's JSON-LD `@context` defines\n   *   the proof terms in the same way, set this flag to `false`.\n   *\n   * @return {Promise<{verified: boolean, results: Array, error: *}>} resolves\n   *   with an object with a `verified`boolean property that is `true` if at\n   *   least one proof matching the given purpose and suite verifies and `false`\n   *   otherwise; a `results` property with an array of detailed results;\n   *   if `false` an `error` property will be present.\n   */\n  async verify(document, {\n    suite, purpose, documentLoader, expansionMap,\n    compactProof = true} = {}) {\n    if(!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if(!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n    const suites = Array.isArray(suite) ? suite : [suite];\n    if(suites.length === 0) {\n      throw new TypeError('At least one suite is required.');\n    }\n\n    const legacy = suites.some(s => s.legacy);\n    if(legacy) {\n      if(suites.some(s => !s.legacy)) {\n        throw new Error(\n          'Legacy suites may not be combined with current suites.');\n      } else if(!(purpose instanceof PublicKeyProofPurpose)) {\n        throw new TypeError(\n          '\"options.purpose\" must be an instance of \"PublicKeyProofPurpose\"' +\n          'to use a legacy suite.');\n      }\n    }\n\n    if(documentLoader) {\n      documentLoader = extendContextLoader(documentLoader);\n    } else {\n      documentLoader = strictDocumentLoader;\n    }\n    if(expansionMap !== false) {\n      expansionMap = strictExpansionMap;\n    }\n\n    try {\n      if(typeof document === 'string') {\n        // fetch document\n        document = await documentLoader(document);\n      } else {\n        // TODO: consider in-place editing to optimize when `compactProof`\n        // is `false`\n\n        // shallow copy to allow for removal of proof set prior to canonize\n        document = {...document};\n      }\n\n      // get proofs from document\n      const {proofSet, document: doc} = await _getProofs({\n        document, legacy, documentLoader, expansionMap, compactProof});\n      document = doc;\n\n      // verify proofs\n      const results = await _verify({\n        document, suites, proofSet,\n        purpose, documentLoader, expansionMap, compactProof});\n      if(results.length === 0) {\n        throw new Error(\n          'Could not verify any proofs; no proofs matched the required ' +\n          'suite and purpose.');\n      }\n\n      // combine results\n      const verified = results.some(r => r.verified);\n      if(!verified) {\n        const errors = [].concat(\n          ...results.filter(r => r.error).map(r => r.error));\n        const result = {verified, results};\n        if(errors.length > 0) {\n          result.error = errors;\n        }\n        return result;\n      }\n      return {verified, results};\n    } catch(error) {\n      _addToJSON(error);\n      return {verified: false, error};\n    }\n  }\n};\n\nasync function _getProofs({\n  document, legacy, documentLoader, expansionMap, compactProof}) {\n  // handle document preprocessing to find proofs\n  const proofProperty = legacy ? 'signature' : 'proof';\n  let proofSet;\n  if(compactProof) {\n    // if we must compact the proof(s) then we must first compact the input\n    // document to find the proof(s)\n    document = await jsonld.compact(\n      document, constants.SECURITY_CONTEXT_URL,\n      {documentLoader, expansionMap, compactToRelative: false});\n  }\n  proofSet = jsonld.getValues(document, proofProperty);\n  delete document[proofProperty];\n\n  if(proofSet.length === 0) {\n    // no possible matches\n    throw new Error('No matching proofs found in the given document.');\n  }\n\n  // TODO: consider in-place editing to optimize\n\n  // shallow copy proofs and add SECURITY_CONTEXT_URL\n  proofSet = proofSet.map(proof => ({\n    '@context': constants.SECURITY_CONTEXT_URL,\n    ...proof\n  }));\n\n  return {proofSet, document};\n}\n\nasync function _verify({\n  document, suites, proofSet, purpose,\n  documentLoader, expansionMap, compactProof}) {\n  // filter out matching proofs\n  const result = await Promise.all(proofSet.map(proof =>\n    purpose.match(proof, {document, documentLoader, expansionMap})));\n  const matches = proofSet.filter((value, index) => result[index]);\n  if(matches.length === 0) {\n    // no matches, nothing to verify\n    return [];\n  }\n\n  // verify each matching proof\n  return (await Promise.all(matches.map(async proof => {\n    for(const s of suites) {\n      if(await s.matchProof({proof, document, documentLoader, expansionMap})) {\n        return s.verifyProof({\n          proof, document, purpose, documentLoader, expansionMap,\n          compactProof}).catch(error => ({verified: false, error}));\n      }\n    }\n  }))).map((r, i) => {\n    if(!r) {\n      return null;\n    }\n    if(r.error) {\n      _addToJSON(r.error);\n    }\n    return {proof: matches[i], ...r};\n  }).filter(r => r);\n}\n\n// add a `toJSON` method to an error which allows for errors in validation\n// reports to be serialized properly by `JSON.stringify`.\nfunction _addToJSON(error) {\n  Object.defineProperty(error, 'toJSON', {\n    value: function() {\n      return serializeError(this);\n    },\n    configurable: true,\n    writable: true\n  });\n}\n\nasync function _getTypeInfo({document, documentLoader, expansionMap}) {\n  // determine `@type` alias, if any\n  const ctx = jsonld.getValues(document, '@context');\n  const compacted = await jsonld.compact(\n    {'@type': '_:b0'}, ctx, {documentLoader, expansionMap});\n  delete compacted['@context'];\n  const alias = Object.keys(compacted)[0];\n\n  // optimize: expand only `@type` and `type` values\n  const toExpand = {'@context': ctx};\n  toExpand['@type'] = jsonld.getValues(document, '@type')\n    .concat(jsonld.getValues(document, alias));\n  const expanded = (await jsonld.expand(\n    toExpand, {documentLoader, expansionMap}))[0] || {};\n  return {types: jsonld.getValues(expanded, '@type'), alias};\n}\n"]},"metadata":{},"sourceType":"script"}