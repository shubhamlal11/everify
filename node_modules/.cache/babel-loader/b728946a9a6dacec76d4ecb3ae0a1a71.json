{"ast":null,"code":"/*!\n * Copyright (c) 2018-2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst env = require('./env');\n\nconst forge = require('node-forge');\n\nconst {\n  md: {\n    sha256\n  },\n  pki: {\n    getPublicKeyFingerprint,\n    publicKeyFromPem\n  },\n  util: {\n    binary: {\n      base58,\n      raw\n    }\n  }\n} = forge;\n\nconst LDKeyPair = require('./LDKeyPair');\n/**\n * @constant\n * @type {number}\n * @default\n */\n\n\nconst DEFAULT_RSA_KEY_BITS = 2048;\n/**\n * @constant\n * @type {number}\n * @default\n */\n\nconst DEFAULT_RSA_EXPONENT = 0x10001;\n\nclass RSAKeyPair extends LDKeyPair {\n  /* eslint-disable max-len */\n\n  /**\n   * An implementation of\n   * [RSA encryption]{@link https://simple.wikipedia.org/wiki/RSA_algorithm}\n   * for\n   * [jsonld-signatures]{@link https://github.com/digitalbazaar/jsonld-signatures}.\n   * @example\n   * > const options = {\n   *    privateKeyPem: 'testPrivateKey',\n   *    publicKeyPem: 'testPublicKey'\n   *  };\n   * > const RSAKey = new RSAKeyPair(options);\n   * @param {KeyPairOptions} options - Keys must be in RSA format other\n   * options must follow [KeyPairOptions]{@link ./index.md#KeyPairOptions}.\n   * @param {string} options.publicKeyPem - Public Key for Signatures.\n   * @param {string} options.privateKeyPem - Your Confidential key for signing.\n   */\n\n  /* eslint-enable */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(options);\n    this.type = 'RsaVerificationKey2018';\n    this.privateKeyPem = options.privateKeyPem;\n    this.publicKeyPem = options.publicKeyPem;\n    this.validateKeyParams(); // validate keyBits and exponent\n  }\n  /**\n   * Returns the public key.\n   * @implements {LDKeyPair#publicKey}\n   * @readonly\n   *\n   * @returns {string} The public key.\n   * @see [publicKey]{@link ./LDKeyPair.md#publicKey}\n   */\n\n\n  get publicKey() {\n    return this.publicKeyPem;\n  }\n  /**\n   * Returns the private key.\n   * @implements {LDKeyPair#privateKey}\n   * @readonly\n   *\n   * @returns {string} The private key.\n   * @see [privateKey]{@link ./LDKeyPair.md#privateKey}\n   */\n\n\n  get privateKey() {\n    return this.privateKeyPem;\n  }\n  /**\n   * Generates an RSA KeyPair using the RSA Defaults.\n   * @example\n   * > const keyPair = await RSAKeyPair.generate();\n   * > keyPair\n   * RSAKeyPair { ...\n   * @param {KeyPairOptions} [options={}] - See LDKeyPair\n   * docstring for full list.\n   *\n   * @returns {Promise<RSAKeyPair>} A Default encrypted RSA KeyPair.\n   * @see [KeyPairOptions]{@link ./index.md#KeyPairOptions}\n   */\n\n\n  static async generate() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // forge will use a native implementation in nodejs >= 10.12.0\n    // and a purejs implementation in browser and nodejs < 10.12.0\n    return new Promise((resolve, reject) => {\n      forge.pki.rsa.generateKeyPair({\n        bits: DEFAULT_RSA_KEY_BITS,\n        e: DEFAULT_RSA_EXPONENT,\n        workers: -1\n      }, (err, keyPair) => {\n        if (err) {\n          return reject(err);\n        }\n\n        resolve(new RSAKeyPair({\n          publicKeyPem: forge.pki.publicKeyToPem(keyPair.publicKey),\n          privateKeyPem: forge.pki.privateKeyToPem(keyPair.privateKey),\n          ...options\n        }));\n      });\n    });\n  }\n  /**\n   * Creates a RSA Key Pair from an existing private key.\n   * @example\n   * > const options = {\n   *    privateKeyPem: 'testkeypem'\n   *  };\n   * > const key = await RSAKeyPair.from(options);\n   * @param {Object} options - Contains a private key.\n   * @param {Object} [options.privateKey] - A private key.\n   * @param {string} [options.privateKeyPem] - An RSA Private key.\n   *\n   * @returns {RSAKeyPair} An RSA Key Pair.\n   */\n\n\n  static async from(options) {\n    const privateKeyPem = options.privateKeyPem || // legacy privateDidDoc format\n    options.privateKeyPem && options.privateKey.privateKeyPem;\n    const keys = new RSAKeyPair({\n      publicKey: options.publicKeyPem,\n      privateKeyPem,\n      type: options.type || options.keyType,\n      // todo: deprecate keyType usage\n      ...options\n    });\n    return keys;\n  }\n  /**\n   * Validates this key.\n   * @example\n   * > rsaKeyPair.validateKeyParams();\n   * undefined\n   *\n   * @returns {undefined} If it does not throw then the key is valid.\n   * @throws Invalid RSA keyBit length\n   * @throws Invalid RSA exponent\n   */\n\n\n  validateKeyParams() {\n    if (this.publicKeyPem) {\n      const publicKey = forge.pki.publicKeyFromPem(this.publicKeyPem);\n      const keyBits = publicKey.n.bitLength();\n\n      if (keyBits !== DEFAULT_RSA_KEY_BITS) {\n        throw new Error(`Invalid RSA keyBit length ${JSON.stringify(keyBits)}` + ` required value is ${DEFAULT_RSA_KEY_BITS}`);\n      }\n\n      if (publicKey.e.toString(10) !== '65537') {\n        throw new Error(`Invalid RSA exponent ${JSON.stringify(publicKey.e.toString(10))}` + ' required value is 65537}');\n      }\n    }\n\n    if (this.privateKeyPem) {\n      const privateKey = forge.pki.privateKeyFromPem(this.privateKeyPem);\n      const keyBits = privateKey.n.bitLength();\n\n      if (keyBits !== DEFAULT_RSA_KEY_BITS) {\n        throw new Error(`Invalid RSA keyBit length ${JSON.stringify(keyBits)}` + ` required value is ${DEFAULT_RSA_KEY_BITS}`);\n      }\n\n      if (privateKey.e.toString(10) !== '65537') {\n        throw new Error(`Invalid RSA exponent ${JSON.stringify(privateKey.e.toString(10))}` + ' required value is 65537}');\n      }\n    }\n  }\n  /**\n   * Adds this KeyPair's publicKeyPem to a public node.\n   * @example\n   * > rsaKeyPair.addEncodedPublicKey({id: 'testnode'});\n   * { publicKeyPem: 'testPublicKey' }\n   * @param {KeyPairOptions} publicKeyNode - A Node with out a publicKeyPem set.\n   *\n   * @returns {KeyPairOptions} A public node with a publicKeyPem set.\n   * @see [KeyPairOptions]{@link ./index.md#KeyPairOptions}\n   */\n\n\n  addEncodedPublicKey(publicKeyNode) {\n    publicKeyNode.publicKeyPem = this.publicKeyPem;\n    return publicKeyNode;\n  }\n  /**\n   * Adds this KeyPair's privateKeyPem to a public node.\n   * @example\n   * > rsaKeyPair.addEncryptedPrivateKey({id: 'testnode'});\n   * { privateKeyPem: 'testPrivateKey' }\n   * @param {KeyPairOptions} keyNode - A Node with out a publicKeyPem set.\n   *\n   * @returns {KeyPairOptions} A public node with a privateKeyPem set.\n   * @see [KeyPairOptions]{@link ./index.md#KeyPairOptions}\n   */\n\n\n  async addEncryptedPrivateKey(keyNode) {\n    if (this.passphrase !== null) {\n      keyNode.privateKeyPem = forge.pki.encryptRsaPrivateKey(forge.pki.privateKeyFromPem(this.privateKeyPem), this.passphrase, {\n        algorithm: 'aes256'\n      });\n    } else {\n      // no passphrase, do not encrypt private key\n      keyNode.privateKeyPem = this.privateKeyPem;\n    }\n\n    return keyNode;\n  }\n  /**\n   * Generates and returns a multiformats\n   * encoded RSA public key fingerprint (for use with cryptonyms, for example).\n   * @example\n   * > rsaKeyPair.fingerprint();\n   * 3423dfdsf3432sdfdsds\n   *\n   * @returns {string} An RSA fingerprint.\n   */\n\n\n  fingerprint() {\n    const buffer = forge.util.createBuffer(); // use SubjectPublicKeyInfo fingerprint\n\n    const fingerprintBuffer = forge.pki.getPublicKeyFingerprint(forge.pki.publicKeyFromPem(this.publicKeyPem), {\n      md: sha256.create()\n    }); // RSA cryptonyms are multiformats encoded values, specifically they are:\n    // (multicodec RSA SPKI-based public key 0x5d + sha2-256 0x12 +\n    // 32 byte value 0x20)\n\n    buffer.putBytes(forge.util.hexToBytes('5d1220'));\n    buffer.putBytes(fingerprintBuffer.bytes()); // prefix with `z` to indicate multi-base base58btc encoding\n\n    return `z${base58.encode(buffer)}`;\n  }\n  /*\n   * Tests whether the fingerprint\n   * was generated from a given key pair.\n   * @example\n   * > rsaKeyPair.verifyFingerprint('zdsfdsfsdfdsfsd34234');\n   * {valid: true}\n   * @param {string} fingerprint - An RSA fingerprint for a key.\n   *\n   * @returns {boolean} True if the fingerprint is verified.\n   */\n\n\n  verifyFingerprint(fingerprint) {\n    // fingerprint should have `z` prefix indicating\n    // that it's multi-base encoded\n    if (!(typeof fingerprint === 'string' && fingerprint[0] === 'z')) {\n      return {\n        error: new Error('`fingerprint` must be a multibase encoded string.'),\n        valid: false\n      };\n    } // base58.decode returns Buffer(nodejs) or Uint8Array\n\n\n    const fingerprintBuffer = base58.decode(fingerprint.slice(1)); // keyFingerprintBuffer is a forge ByteStringBuffer\n\n    const keyFingerprintBuffer = getPublicKeyFingerprint(publicKeyFromPem(this.publicKeyPem), {\n      md: sha256.create()\n    }); // validate the first three multicodec bytes 0x5d1220\n\n    const valid = fingerprintBuffer.slice(0, 3).toString('hex') === '5d1220' && keyFingerprintBuffer.toHex() === fingerprintBuffer.slice(3).toString('hex');\n\n    if (!valid) {\n      return {\n        error: new Error('The fingerprint does not match the public key.'),\n        valid: false\n      };\n    }\n\n    return {\n      valid\n    };\n  }\n  /* eslint-disable max-len */\n\n  /**\n   * Returns a signer object with an async sign function for use by\n   * [jsonld-signatures]{@link https://github.com/digitalbazaar/jsonld-signatures}\n   * to sign content in a signature.\n   * @example\n   * > const signer = rsaKeyPair.signer();\n   * > signer.sign({data});\n   *\n   * @returns {{sign: Function}} An RSA Signer Function for a single key.\n   * for a single Private Key.\n   */\n\n  /* eslint-enable */\n\n\n  signer() {\n    return rsaSignerFactory(this);\n  }\n  /* eslint-disable max-len */\n\n  /**\n   * Returns a verifier object with an async\n   * function verify for use with\n   * [jsonld-signatures]{@link https://github.com/digitalbazaar/jsonld-signatures}.\n   * @example\n   * > const verifier = rsaKeyPair.verifier();\n   * > const valid = await verifier.verify({data, signature});\n   *\n   * @returns {{verify: Function}} An RSA Verifier Function for a single key.\n   */\n\n  /* eslint-enable */\n\n\n  verifier() {\n    return rsaVerifierFactory(this);\n  }\n\n}\n/**\n * @ignore\n * Returns an object with an async sign function.\n * The sign function is bound to the KeyPair\n * and then returned by the KeyPair's signer method.\n * @example\n * > const factory = rsaSignerFactory(rsaKeyPair);\n * > const bytes = await factory.sign({data});\n * @param {RSAKeyPair} key - They key this factory will verify for.\n *\n * @returns {{sign: Function}} An RSA Verifier Function for a single key.\n */\n\n\nfunction rsaSignerFactory(key) {\n  if (!key.privateKeyPem) {\n    return {\n      async sign() {\n        throw new Error('No private key to sign with.');\n      }\n\n    };\n  } // Note: Per rfc7518, the digest algorithm for PS256 is SHA-256,\n  // https://tools.ietf.org/html/rfc7518\n  // sign data using RSASSA-PSS where PSS uses a SHA-256 hash,\n  // a SHA-256 based masking function MGF1, and a 32 byte salt to match\n  // the hash size\n\n\n  if (env.nodejs) {\n    // node.js 8+\n    const crypto = require('crypto');\n\n    if ('RSA_PKCS1_PSS_PADDING' in crypto.constants) {\n      return {\n        async sign(_ref) {\n          let {\n            data\n          } = _ref;\n          const signer = crypto.createSign('RSA-SHA256');\n          signer.update(Buffer.from(data.buffer, data.byteOffset, data.length));\n          const buffer = signer.sign({\n            key: key.privateKeyPem,\n            padding: crypto.constants.RSA_PKCS1_PSS_PADDING,\n            saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST\n          });\n          return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.length);\n        }\n\n      };\n    }\n  } // browser or other environment (including node 6.x)\n\n\n  const privateKey = forge.pki.privateKeyFromPem(key.privateKeyPem);\n  return {\n    async sign(_ref2) {\n      let {\n        data\n      } = _ref2;\n      const pss = createPss();\n      const md = sha256.create();\n      md.update(raw.encode(data), 'binary');\n      const binaryString = privateKey.sign(md, pss);\n      return raw.decode(binaryString);\n    }\n\n  };\n}\n/**\n * @ignore\n * Returns an object with an async verify function.\n * The verify function is bound to the KeyPair\n * and then returned by the KeyPair's verifier method.\n * @example\n * > const verifier = rsaVerifierFactory(rsaKeyPair);\n * > verifier.verify({data, signature});\n * false\n * @param {RSAKeyPair} key - An RSAKeyPair.\n *\n * @returns {Function} An RSA Verifier for the key pair passed in.\n */\n\n\nfunction rsaVerifierFactory(key) {\n  if (env.nodejs) {\n    // node.js 8+\n    const crypto = require('crypto');\n\n    if ('RSA_PKCS1_PSS_PADDING' in crypto.constants) {\n      return {\n        async verify(_ref3) {\n          let {\n            data,\n            signature\n          } = _ref3;\n          const verifier = crypto.createVerify('RSA-SHA256');\n          verifier.update(Buffer.from(data.buffer, data.byteOffset, data.length));\n          return verifier.verify({\n            key: key.publicKeyPem,\n            padding: crypto.constants.RSA_PKCS1_PSS_PADDING,\n            saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST\n          }, Buffer.from(signature.buffer, signature.byteOffset, signature.length));\n        }\n\n      };\n    }\n  } // browser or other environment (including node 6.x)\n\n\n  const publicKey = publicKeyFromPem(key.publicKeyPem);\n  return {\n    async verify(_ref4) {\n      let {\n        data,\n        signature\n      } = _ref4;\n      const pss = createPss();\n      const md = sha256.create();\n      md.update(raw.encode(data), 'binary');\n\n      try {\n        return publicKey.verify(md.digest().bytes(), raw.encode(signature), pss);\n      } catch (e) {\n        // simply return false, do return information about malformed signature\n        return false;\n      }\n    }\n\n  };\n}\n/**\n * @ignore\n * creates an RSA PSS used in signatures.\n * @example\n * > const pss = createPss();\n *\n * @returns {PSS} A PSS object.\n * @see [PSS]{@link ./index.md#PSS}\n */\n\n\nfunction createPss() {\n  const md = sha256.create();\n  return forge.pss.create({\n    md,\n    mgf: forge.mgf.mgf1.create(sha256.create()),\n    saltLength: md.digestLength\n  });\n}\n\nmodule.exports = RSAKeyPair;","map":{"version":3,"sources":["/Users/shubhamlal/Desktop/verification/node_modules/crypto-ld/lib/RSAKeyPair.js"],"names":["env","require","forge","md","sha256","pki","getPublicKeyFingerprint","publicKeyFromPem","util","binary","base58","raw","LDKeyPair","DEFAULT_RSA_KEY_BITS","DEFAULT_RSA_EXPONENT","RSAKeyPair","constructor","options","type","privateKeyPem","publicKeyPem","validateKeyParams","publicKey","privateKey","generate","Promise","resolve","reject","rsa","generateKeyPair","bits","e","workers","err","keyPair","publicKeyToPem","privateKeyToPem","from","keys","keyType","keyBits","n","bitLength","Error","JSON","stringify","toString","privateKeyFromPem","addEncodedPublicKey","publicKeyNode","addEncryptedPrivateKey","keyNode","passphrase","encryptRsaPrivateKey","algorithm","fingerprint","buffer","createBuffer","fingerprintBuffer","create","putBytes","hexToBytes","bytes","encode","verifyFingerprint","error","valid","decode","slice","keyFingerprintBuffer","toHex","signer","rsaSignerFactory","verifier","rsaVerifierFactory","key","sign","nodejs","crypto","constants","data","createSign","update","Buffer","byteOffset","length","padding","RSA_PKCS1_PSS_PADDING","saltLength","RSA_PSS_SALTLEN_DIGEST","Uint8Array","pss","createPss","binaryString","verify","signature","createVerify","digest","mgf","mgf1","digestLength","module","exports"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2018-2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst env = require('./env');\nconst forge = require('node-forge');\nconst {\n  md: {sha256},\n  pki: {getPublicKeyFingerprint, publicKeyFromPem},\n  util: {binary: {base58, raw}}\n} = forge;\nconst LDKeyPair = require('./LDKeyPair');\n\n/**\n * @constant\n * @type {number}\n * @default\n */\nconst DEFAULT_RSA_KEY_BITS = 2048;\n\n/**\n * @constant\n * @type {number}\n * @default\n */\nconst DEFAULT_RSA_EXPONENT = 0x10001;\n\nclass RSAKeyPair extends LDKeyPair {\n  /* eslint-disable max-len */\n  /**\n   * An implementation of\n   * [RSA encryption]{@link https://simple.wikipedia.org/wiki/RSA_algorithm}\n   * for\n   * [jsonld-signatures]{@link https://github.com/digitalbazaar/jsonld-signatures}.\n   * @example\n   * > const options = {\n   *    privateKeyPem: 'testPrivateKey',\n   *    publicKeyPem: 'testPublicKey'\n   *  };\n   * > const RSAKey = new RSAKeyPair(options);\n   * @param {KeyPairOptions} options - Keys must be in RSA format other\n   * options must follow [KeyPairOptions]{@link ./index.md#KeyPairOptions}.\n   * @param {string} options.publicKeyPem - Public Key for Signatures.\n   * @param {string} options.privateKeyPem - Your Confidential key for signing.\n   */\n  /* eslint-enable */\n  constructor(options = {}) {\n    super(options);\n    this.type = 'RsaVerificationKey2018';\n    this.privateKeyPem = options.privateKeyPem;\n    this.publicKeyPem = options.publicKeyPem;\n\n    this.validateKeyParams(); // validate keyBits and exponent\n  }\n  /**\n   * Returns the public key.\n   * @implements {LDKeyPair#publicKey}\n   * @readonly\n   *\n   * @returns {string} The public key.\n   * @see [publicKey]{@link ./LDKeyPair.md#publicKey}\n   */\n  get publicKey() {\n    return this.publicKeyPem;\n  }\n  /**\n   * Returns the private key.\n   * @implements {LDKeyPair#privateKey}\n   * @readonly\n   *\n   * @returns {string} The private key.\n   * @see [privateKey]{@link ./LDKeyPair.md#privateKey}\n   */\n  get privateKey() {\n    return this.privateKeyPem;\n  }\n\n  /**\n   * Generates an RSA KeyPair using the RSA Defaults.\n   * @example\n   * > const keyPair = await RSAKeyPair.generate();\n   * > keyPair\n   * RSAKeyPair { ...\n   * @param {KeyPairOptions} [options={}] - See LDKeyPair\n   * docstring for full list.\n   *\n   * @returns {Promise<RSAKeyPair>} A Default encrypted RSA KeyPair.\n   * @see [KeyPairOptions]{@link ./index.md#KeyPairOptions}\n   */\n  static async generate(options = {}) {\n    // forge will use a native implementation in nodejs >= 10.12.0\n    // and a purejs implementation in browser and nodejs < 10.12.0\n    return new Promise((resolve, reject) => {\n      forge.pki.rsa.generateKeyPair({\n        bits: DEFAULT_RSA_KEY_BITS,\n        e: DEFAULT_RSA_EXPONENT,\n        workers: -1\n      }, (err, keyPair) => {\n        if(err) {\n          return reject(err);\n        }\n        resolve(new RSAKeyPair({\n          publicKeyPem: forge.pki.publicKeyToPem(keyPair.publicKey),\n          privateKeyPem: forge.pki.privateKeyToPem(keyPair.privateKey),\n          ...options\n        }));\n      });\n    });\n  }\n  /**\n   * Creates a RSA Key Pair from an existing private key.\n   * @example\n   * > const options = {\n   *    privateKeyPem: 'testkeypem'\n   *  };\n   * > const key = await RSAKeyPair.from(options);\n   * @param {Object} options - Contains a private key.\n   * @param {Object} [options.privateKey] - A private key.\n   * @param {string} [options.privateKeyPem] - An RSA Private key.\n   *\n   * @returns {RSAKeyPair} An RSA Key Pair.\n   */\n  static async from(options) {\n    const privateKeyPem = options.privateKeyPem ||\n      // legacy privateDidDoc format\n      (options.privateKeyPem && options.privateKey.privateKeyPem);\n\n    const keys = new RSAKeyPair({\n      publicKey: options.publicKeyPem,\n      privateKeyPem,\n      type: options.type || options.keyType, // todo: deprecate keyType usage\n      ...options\n    });\n\n    return keys;\n  }\n  /**\n   * Validates this key.\n   * @example\n   * > rsaKeyPair.validateKeyParams();\n   * undefined\n   *\n   * @returns {undefined} If it does not throw then the key is valid.\n   * @throws Invalid RSA keyBit length\n   * @throws Invalid RSA exponent\n   */\n  validateKeyParams() {\n    if(this.publicKeyPem) {\n      const publicKey = forge.pki.publicKeyFromPem(this.publicKeyPem);\n      const keyBits = publicKey.n.bitLength();\n      if(keyBits !== DEFAULT_RSA_KEY_BITS) {\n        throw new Error(`Invalid RSA keyBit length ${JSON.stringify(keyBits)}` +\n          ` required value is ${DEFAULT_RSA_KEY_BITS}`);\n      }\n      if(publicKey.e.toString(10) !== '65537') {\n        throw new Error(\n          `Invalid RSA exponent ${JSON.stringify(publicKey.e.toString(10))}` +\n          ' required value is 65537}');\n      }\n    }\n\n    if(this.privateKeyPem) {\n      const privateKey = forge.pki.privateKeyFromPem(this.privateKeyPem);\n      const keyBits = privateKey.n.bitLength();\n      if(keyBits !== DEFAULT_RSA_KEY_BITS) {\n        throw new Error(`Invalid RSA keyBit length ${JSON.stringify(keyBits)}` +\n          ` required value is ${DEFAULT_RSA_KEY_BITS}`);\n      }\n      if(privateKey.e.toString(10) !== '65537') {\n        throw new Error(\n          `Invalid RSA exponent ${JSON.stringify(privateKey.e.toString(10))}` +\n          ' required value is 65537}');\n      }\n    }\n  }\n\n  /**\n   * Adds this KeyPair's publicKeyPem to a public node.\n   * @example\n   * > rsaKeyPair.addEncodedPublicKey({id: 'testnode'});\n   * { publicKeyPem: 'testPublicKey' }\n   * @param {KeyPairOptions} publicKeyNode - A Node with out a publicKeyPem set.\n   *\n   * @returns {KeyPairOptions} A public node with a publicKeyPem set.\n   * @see [KeyPairOptions]{@link ./index.md#KeyPairOptions}\n   */\n  addEncodedPublicKey(publicKeyNode) {\n    publicKeyNode.publicKeyPem = this.publicKeyPem;\n    return publicKeyNode;\n  }\n  /**\n   * Adds this KeyPair's privateKeyPem to a public node.\n   * @example\n   * > rsaKeyPair.addEncryptedPrivateKey({id: 'testnode'});\n   * { privateKeyPem: 'testPrivateKey' }\n   * @param {KeyPairOptions} keyNode - A Node with out a publicKeyPem set.\n   *\n   * @returns {KeyPairOptions} A public node with a privateKeyPem set.\n   * @see [KeyPairOptions]{@link ./index.md#KeyPairOptions}\n   */\n  async addEncryptedPrivateKey(keyNode) {\n    if(this.passphrase !== null) {\n      keyNode.privateKeyPem = forge.pki.encryptRsaPrivateKey(\n        forge.pki.privateKeyFromPem(this.privateKeyPem),\n        this.passphrase,\n        {algorithm: 'aes256'}\n      );\n    } else {\n      // no passphrase, do not encrypt private key\n      keyNode.privateKeyPem = this.privateKeyPem;\n    }\n    return keyNode;\n  }\n\n  /**\n   * Generates and returns a multiformats\n   * encoded RSA public key fingerprint (for use with cryptonyms, for example).\n   * @example\n   * > rsaKeyPair.fingerprint();\n   * 3423dfdsf3432sdfdsds\n   *\n   * @returns {string} An RSA fingerprint.\n   */\n  fingerprint() {\n    const buffer = forge.util.createBuffer();\n\n    // use SubjectPublicKeyInfo fingerprint\n    const fingerprintBuffer = forge.pki.getPublicKeyFingerprint(\n      forge.pki.publicKeyFromPem(this.publicKeyPem),\n      {md: sha256.create()});\n    // RSA cryptonyms are multiformats encoded values, specifically they are:\n    // (multicodec RSA SPKI-based public key 0x5d + sha2-256 0x12 +\n    // 32 byte value 0x20)\n    buffer.putBytes(forge.util.hexToBytes('5d1220'));\n    buffer.putBytes(fingerprintBuffer.bytes());\n\n    // prefix with `z` to indicate multi-base base58btc encoding\n    return `z${base58.encode(buffer)}`;\n  }\n\n  /*\n   * Tests whether the fingerprint\n   * was generated from a given key pair.\n   * @example\n   * > rsaKeyPair.verifyFingerprint('zdsfdsfsdfdsfsd34234');\n   * {valid: true}\n   * @param {string} fingerprint - An RSA fingerprint for a key.\n   *\n   * @returns {boolean} True if the fingerprint is verified.\n   */\n  verifyFingerprint(fingerprint) {\n    // fingerprint should have `z` prefix indicating\n    // that it's multi-base encoded\n    if(!(typeof fingerprint === 'string' && fingerprint[0] === 'z')) {\n      return {\n        error: new Error('`fingerprint` must be a multibase encoded string.'),\n        valid: false\n      };\n    }\n    // base58.decode returns Buffer(nodejs) or Uint8Array\n    const fingerprintBuffer = base58.decode(fingerprint.slice(1));\n    // keyFingerprintBuffer is a forge ByteStringBuffer\n    const keyFingerprintBuffer = getPublicKeyFingerprint(\n      publicKeyFromPem(this.publicKeyPem), {md: sha256.create()});\n\n    // validate the first three multicodec bytes 0x5d1220\n    const valid = fingerprintBuffer.slice(0, 3).toString('hex') === '5d1220' &&\n      keyFingerprintBuffer.toHex() ===\n      fingerprintBuffer.slice(3).toString('hex');\n    if(!valid) {\n      return {\n        error: new Error('The fingerprint does not match the public key.'),\n        valid: false\n      };\n    }\n\n    return {valid};\n  }\n\n  /* eslint-disable max-len */\n  /**\n   * Returns a signer object with an async sign function for use by\n   * [jsonld-signatures]{@link https://github.com/digitalbazaar/jsonld-signatures}\n   * to sign content in a signature.\n   * @example\n   * > const signer = rsaKeyPair.signer();\n   * > signer.sign({data});\n   *\n   * @returns {{sign: Function}} An RSA Signer Function for a single key.\n   * for a single Private Key.\n   */\n  /* eslint-enable */\n  signer() {\n    return rsaSignerFactory(this);\n  }\n\n  /* eslint-disable max-len */\n  /**\n   * Returns a verifier object with an async\n   * function verify for use with\n   * [jsonld-signatures]{@link https://github.com/digitalbazaar/jsonld-signatures}.\n   * @example\n   * > const verifier = rsaKeyPair.verifier();\n   * > const valid = await verifier.verify({data, signature});\n   *\n   * @returns {{verify: Function}} An RSA Verifier Function for a single key.\n   */\n  /* eslint-enable */\n  verifier() {\n    return rsaVerifierFactory(this);\n  }\n}\n\n/**\n * @ignore\n * Returns an object with an async sign function.\n * The sign function is bound to the KeyPair\n * and then returned by the KeyPair's signer method.\n * @example\n * > const factory = rsaSignerFactory(rsaKeyPair);\n * > const bytes = await factory.sign({data});\n * @param {RSAKeyPair} key - They key this factory will verify for.\n *\n * @returns {{sign: Function}} An RSA Verifier Function for a single key.\n */\nfunction rsaSignerFactory(key) {\n  if(!key.privateKeyPem) {\n    return {\n      async sign() {\n        throw new Error('No private key to sign with.');\n      }\n    };\n  }\n\n  // Note: Per rfc7518, the digest algorithm for PS256 is SHA-256,\n  // https://tools.ietf.org/html/rfc7518\n\n  // sign data using RSASSA-PSS where PSS uses a SHA-256 hash,\n  // a SHA-256 based masking function MGF1, and a 32 byte salt to match\n  // the hash size\n  if(env.nodejs) {\n    // node.js 8+\n    const crypto = require('crypto');\n    if('RSA_PKCS1_PSS_PADDING' in crypto.constants) {\n      return {\n        async sign({data}) {\n          const signer = crypto.createSign('RSA-SHA256');\n          signer.update(Buffer.from(data.buffer, data.byteOffset, data.length));\n          const buffer = signer.sign({\n            key: key.privateKeyPem,\n            padding: crypto.constants.RSA_PKCS1_PSS_PADDING,\n            saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST\n          });\n          return new Uint8Array(\n            buffer.buffer, buffer.byteOffset, buffer.length);\n        }\n      };\n    }\n  }\n\n  // browser or other environment (including node 6.x)\n  const privateKey = forge.pki.privateKeyFromPem(key.privateKeyPem);\n  return {\n    async sign({data}) {\n      const pss = createPss();\n      const md = sha256.create();\n      md.update(raw.encode(data), 'binary');\n      const binaryString = privateKey.sign(md, pss);\n      return raw.decode(binaryString);\n    }\n  };\n}\n\n/**\n * @ignore\n * Returns an object with an async verify function.\n * The verify function is bound to the KeyPair\n * and then returned by the KeyPair's verifier method.\n * @example\n * > const verifier = rsaVerifierFactory(rsaKeyPair);\n * > verifier.verify({data, signature});\n * false\n * @param {RSAKeyPair} key - An RSAKeyPair.\n *\n * @returns {Function} An RSA Verifier for the key pair passed in.\n */\nfunction rsaVerifierFactory(key) {\n  if(env.nodejs) {\n    // node.js 8+\n    const crypto = require('crypto');\n    if('RSA_PKCS1_PSS_PADDING' in crypto.constants) {\n      return {\n        async verify({data, signature}) {\n          const verifier = crypto.createVerify('RSA-SHA256');\n          verifier.update(\n            Buffer.from(data.buffer, data.byteOffset, data.length));\n          return verifier.verify({\n            key: key.publicKeyPem,\n            padding: crypto.constants.RSA_PKCS1_PSS_PADDING,\n            saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST\n          }, Buffer.from(\n            signature.buffer, signature.byteOffset, signature.length));\n        }\n      };\n    }\n  }\n\n  // browser or other environment (including node 6.x)\n  const publicKey = publicKeyFromPem(key.publicKeyPem);\n  return {\n    async verify({data, signature}) {\n      const pss = createPss();\n      const md = sha256.create();\n      md.update(raw.encode(data), 'binary');\n      try {\n        return publicKey.verify(\n          md.digest().bytes(),\n          raw.encode(signature),\n          pss);\n      } catch(e) {\n        // simply return false, do return information about malformed signature\n        return false;\n      }\n    }\n  };\n}\n\n/**\n * @ignore\n * creates an RSA PSS used in signatures.\n * @example\n * > const pss = createPss();\n *\n * @returns {PSS} A PSS object.\n * @see [PSS]{@link ./index.md#PSS}\n */\nfunction createPss() {\n  const md = sha256.create();\n  return forge.pss.create({\n    md,\n    mgf: forge.mgf.mgf1.create(sha256.create()),\n    saltLength: md.digestLength\n  });\n}\n\nmodule.exports = RSAKeyPair;\n"]},"metadata":{},"sourceType":"script"}