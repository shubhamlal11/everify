{"ast":null,"code":"/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nmodule.exports = class ProofPurpose {\n  /**\n   * @param term {string} the `proofPurpose` term, as defined in the\n   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.\n   * @param [date] {string or Date or integer} the expected date for\n   *   the creation of the proof.\n   * @param [maxTimestampDelta] {integer} a maximum number of seconds that\n   *   the date on the signature can deviate from, defaults to `Infinity`.\n   */\n  constructor() {\n    let {\n      term,\n      date,\n      maxTimestampDelta = Infinity\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (term === undefined) {\n      throw new Error('\"term\" is required.');\n    }\n\n    if (maxTimestampDelta !== undefined && typeof maxTimestampDelta !== 'number') {\n      throw new TypeError('\"maxTimestampDelta\" must be a number.');\n    }\n\n    this.term = term;\n\n    if (date !== undefined) {\n      this.date = new Date(date);\n\n      if (isNaN(this.date)) {\n        throw TypeError(`\"date\" \"${date}\" is not a valid date.`);\n      }\n    }\n\n    this.maxTimestampDelta = maxTimestampDelta;\n  }\n  /**\n   * Called to validate the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (e.g. in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`,\n   *   with the matching purpose to validate.\n   *\n   * @return {Promise<object>} resolves to an object with `valid` and `error`.\n   */\n\n\n  async validate(proof, _ref) {\n    let {\n      document,\n      suite,\n      verificationMethod,\n      documentLoader,\n      expansionMap\n    } = _ref;\n\n    try {\n      // check expiration\n      if (this.maxTimestampDelta !== Infinity) {\n        const expected = (this.date || new Date()).getTime();\n        const delta = this.maxTimestampDelta * 1000;\n        const created = new Date(proof.created).getTime(); // comparing this way handles NaN case where `created` is invalid\n\n        if (!(created >= expected - delta && created <= expected + delta)) {\n          throw new Error('The proof\\'s created timestamp is out of range.');\n        }\n      }\n\n      return {\n        valid: true\n      };\n    } catch (error) {\n      return {\n        valid: false,\n        error\n      };\n    }\n  }\n  /**\n   * Called to update a proof when it is being created, adding any properties\n   * specific to this purpose. This method is called prior to the proof\n   * value being generated such that any properties added may be, for example,\n   * included in a digital signature value.\n   *\n   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`\n   *   to update.\n   *\n   * @return {Promise<object>} resolves to the proof instance (in the\n   *   `constants.SECURITY_CONTEXT_URL`.\n   */\n\n\n  async update(proof, _ref2) {\n    let {\n      document,\n      suite,\n      documentLoader,\n      expansionMap\n    } = _ref2;\n    proof.proofPurpose = this.term;\n    return proof;\n  }\n  /**\n   * Determines if the given proof has a purpose that matches this instance,\n   * i.e. this ProofPurpose instance should be used to validate the given\n   * proof.\n   *\n   * @param proof {object} the proof to check.\n   *\n   * @return {Promise<boolean>} `true` if there's a match, `false` if not.\n   */\n\n\n  async match(proof, _ref3) {\n    let {\n      document,\n      documentLoader,\n      expansionMap\n    } = _ref3;\n    return proof.proofPurpose === this.term;\n  }\n\n};","map":{"version":3,"sources":["/Users/shubhamlal/Desktop/verification/node_modules/jsonld-signatures/lib/purposes/ProofPurpose.js"],"names":["module","exports","ProofPurpose","constructor","term","date","maxTimestampDelta","Infinity","undefined","Error","TypeError","Date","isNaN","validate","proof","document","suite","verificationMethod","documentLoader","expansionMap","expected","getTime","delta","created","valid","error","update","proofPurpose","match"],"mappings":"AAAA;AACA;AACA;AACA;;AAEAA,MAAM,CAACC,OAAP,GAAiB,MAAMC,YAAN,CAAmB;AAClC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,WAAW,GAAkD;AAAA,QAAjD;AAACC,MAAAA,IAAD;AAAOC,MAAAA,IAAP;AAAaC,MAAAA,iBAAiB,GAAGC;AAAjC,KAAiD,uEAAJ,EAAI;;AAC3D,QAAGH,IAAI,KAAKI,SAAZ,EAAuB;AACrB,YAAM,IAAIC,KAAJ,CAAU,qBAAV,CAAN;AACD;;AACD,QAAGH,iBAAiB,KAAKE,SAAtB,IACD,OAAOF,iBAAP,KAA6B,QAD/B,EACyC;AACvC,YAAM,IAAII,SAAJ,CAAc,uCAAd,CAAN;AACD;;AACD,SAAKN,IAAL,GAAYA,IAAZ;;AACA,QAAGC,IAAI,KAAKG,SAAZ,EAAuB;AACrB,WAAKH,IAAL,GAAY,IAAIM,IAAJ,CAASN,IAAT,CAAZ;;AACA,UAAGO,KAAK,CAAC,KAAKP,IAAN,CAAR,EAAqB;AACnB,cAAMK,SAAS,CAAE,WAAUL,IAAK,wBAAjB,CAAf;AACD;AACF;;AACD,SAAKC,iBAAL,GAAyBA,iBAAzB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACgB,QAARO,QAAQ,CACZC,KADY,QAEqB;AAAA,QAD1B;AAACC,MAAAA,QAAD;AAAWC,MAAAA,KAAX;AAAkBC,MAAAA,kBAAlB;AACLC,MAAAA,cADK;AACWC,MAAAA;AADX,KAC0B;;AACjC,QAAI;AACF;AACA,UAAG,KAAKb,iBAAL,KAA2BC,QAA9B,EAAwC;AACtC,cAAMa,QAAQ,GAAG,CAAC,KAAKf,IAAL,IAAa,IAAIM,IAAJ,EAAd,EAA0BU,OAA1B,EAAjB;AACA,cAAMC,KAAK,GAAG,KAAKhB,iBAAL,GAAyB,IAAvC;AACA,cAAMiB,OAAO,GAAG,IAAIZ,IAAJ,CAASG,KAAK,CAACS,OAAf,EAAwBF,OAAxB,EAAhB,CAHsC,CAItC;;AACA,YAAG,EAAEE,OAAO,IAAKH,QAAQ,GAAGE,KAAvB,IAAiCC,OAAO,IAAKH,QAAQ,GAAGE,KAA1D,CAAH,EAAsE;AACpE,gBAAM,IAAIb,KAAJ,CAAU,iDAAV,CAAN;AACD;AACF;;AACD,aAAO;AAACe,QAAAA,KAAK,EAAE;AAAR,OAAP;AACD,KAZD,CAYE,OAAMC,KAAN,EAAa;AACb,aAAO;AAACD,QAAAA,KAAK,EAAE,KAAR;AAAeC,QAAAA;AAAf,OAAP;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACc,QAANC,MAAM,CAACZ,KAAD,SAAyD;AAAA,QAAjD;AAACC,MAAAA,QAAD;AAAWC,MAAAA,KAAX;AAAkBE,MAAAA,cAAlB;AAAkCC,MAAAA;AAAlC,KAAiD;AACnEL,IAAAA,KAAK,CAACa,YAAN,GAAqB,KAAKvB,IAA1B;AACA,WAAOU,KAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACa,QAALc,KAAK,CAACd,KAAD,SAAkD;AAAA,QAA1C;AAACC,MAAAA,QAAD;AAAWG,MAAAA,cAAX;AAA2BC,MAAAA;AAA3B,KAA0C;AAC3D,WAAOL,KAAK,CAACa,YAAN,KAAuB,KAAKvB,IAAnC;AACD;;AAtFiC,CAApC","sourcesContent":["/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nmodule.exports = class ProofPurpose {\n  /**\n   * @param term {string} the `proofPurpose` term, as defined in the\n   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.\n   * @param [date] {string or Date or integer} the expected date for\n   *   the creation of the proof.\n   * @param [maxTimestampDelta] {integer} a maximum number of seconds that\n   *   the date on the signature can deviate from, defaults to `Infinity`.\n   */\n  constructor({term, date, maxTimestampDelta = Infinity} = {}) {\n    if(term === undefined) {\n      throw new Error('\"term\" is required.');\n    }\n    if(maxTimestampDelta !== undefined &&\n      typeof maxTimestampDelta !== 'number') {\n      throw new TypeError('\"maxTimestampDelta\" must be a number.');\n    }\n    this.term = term;\n    if(date !== undefined) {\n      this.date = new Date(date);\n      if(isNaN(this.date)) {\n        throw TypeError(`\"date\" \"${date}\" is not a valid date.`);\n      }\n    }\n    this.maxTimestampDelta = maxTimestampDelta;\n  }\n\n  /**\n   * Called to validate the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (e.g. in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`,\n   *   with the matching purpose to validate.\n   *\n   * @return {Promise<object>} resolves to an object with `valid` and `error`.\n   */\n  async validate(\n    proof, {document, suite, verificationMethod,\n      documentLoader, expansionMap}) {\n    try {\n      // check expiration\n      if(this.maxTimestampDelta !== Infinity) {\n        const expected = (this.date || new Date()).getTime();\n        const delta = this.maxTimestampDelta * 1000;\n        const created = new Date(proof.created).getTime();\n        // comparing this way handles NaN case where `created` is invalid\n        if(!(created >= (expected - delta) && created <= (expected + delta))) {\n          throw new Error('The proof\\'s created timestamp is out of range.');\n        }\n      }\n      return {valid: true};\n    } catch(error) {\n      return {valid: false, error};\n    }\n  }\n\n  /**\n   * Called to update a proof when it is being created, adding any properties\n   * specific to this purpose. This method is called prior to the proof\n   * value being generated such that any properties added may be, for example,\n   * included in a digital signature value.\n   *\n   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`\n   *   to update.\n   *\n   * @return {Promise<object>} resolves to the proof instance (in the\n   *   `constants.SECURITY_CONTEXT_URL`.\n   */\n  async update(proof, {document, suite, documentLoader, expansionMap}) {\n    proof.proofPurpose = this.term;\n    return proof;\n  }\n\n  /**\n   * Determines if the given proof has a purpose that matches this instance,\n   * i.e. this ProofPurpose instance should be used to validate the given\n   * proof.\n   *\n   * @param proof {object} the proof to check.\n   *\n   * @return {Promise<boolean>} `true` if there's a match, `false` if not.\n   */\n  async match(proof, {document, documentLoader, expansionMap}) {\n    return proof.proofPurpose === this.term;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}