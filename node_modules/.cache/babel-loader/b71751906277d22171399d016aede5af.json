{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Symbol = void 0;\n\nconst enum_1 = require(\"./enum\");\n\nclass TypePointer {\n  constructor(ptr, buf) {\n    this.ptr = ptr;\n    this.ptr32 = ptr >> 2;\n    this.buf = buf;\n    this.HEAP8 = new Int8Array(buf);\n    this.HEAPU32 = new Uint32Array(buf);\n    this.HEAP32 = new Int32Array(buf);\n  }\n\n}\n\nclass SymbolPtr extends TypePointer {\n  get type() {\n    return this.HEAPU32[this.ptr32];\n  }\n\n  get data() {\n    const len = this.HEAPU32[this.ptr32 + 4];\n    const ptr = this.HEAPU32[this.ptr32 + 5];\n    return Int8Array.from(this.HEAP8.subarray(ptr, ptr + len));\n  }\n\n  get points() {\n    const len = this.HEAPU32[this.ptr32 + 7];\n    const ptr = this.HEAPU32[this.ptr32 + 8];\n    const ptr32 = ptr >> 2;\n    const res = [];\n\n    for (let i = 0; i < len; ++i) {\n      const x = this.HEAP32[ptr32 + i * 2];\n      const y = this.HEAP32[ptr32 + i * 2 + 1];\n      res.push({\n        x,\n        y\n      });\n    }\n\n    return res;\n  }\n\n  get next() {\n    const ptr = this.HEAPU32[this.ptr32 + 11];\n    if (!ptr) return null;\n    return new SymbolPtr(ptr, this.buf);\n  }\n\n  get time() {\n    return this.HEAPU32[this.ptr32 + 13];\n  }\n\n  get cacheCount() {\n    return this.HEAP32[this.ptr32 + 14];\n  }\n\n  get quality() {\n    return this.HEAP32[this.ptr32 + 15];\n  }\n\n}\n\nclass SymbolSetPtr extends TypePointer {\n  get head() {\n    const ptr = this.HEAPU32[this.ptr32 + 2];\n    if (!ptr) return null;\n    return new SymbolPtr(ptr, this.buf);\n  }\n\n}\n\nclass Symbol {\n  constructor(ptr) {\n    this.type = ptr.type;\n    this.typeName = enum_1.ZBarSymbolType[this.type];\n    this.data = ptr.data;\n    this.points = ptr.points;\n    this.time = ptr.time;\n    this.cacheCount = ptr.cacheCount;\n    this.quality = ptr.quality;\n  }\n\n  static createSymbolsFromPtr(ptr, buf) {\n    if (ptr == 0) return [];\n    const set = new SymbolSetPtr(ptr, buf);\n    let symbol = set.head;\n    const res = [];\n\n    while (symbol !== null) {\n      res.push(new Symbol(symbol));\n      symbol = symbol.next;\n    }\n\n    return res;\n  }\n\n  decode(encoding) {\n    const decoder = new TextDecoder(encoding);\n    return decoder.decode(this.data);\n  }\n\n}\n\nexports.Symbol = Symbol;","map":{"version":3,"sources":["../src/Symbol.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Symbol = void 0;\nconst enum_1 = require(\"./enum\");\nclass TypePointer {\n    constructor(ptr, buf) {\n        this.ptr = ptr;\n        this.ptr32 = ptr >> 2;\n        this.buf = buf;\n        this.HEAP8 = new Int8Array(buf);\n        this.HEAPU32 = new Uint32Array(buf);\n        this.HEAP32 = new Int32Array(buf);\n    }\n}\nclass SymbolPtr extends TypePointer {\n    get type() {\n        return this.HEAPU32[this.ptr32];\n    }\n    get data() {\n        const len = this.HEAPU32[this.ptr32 + 4];\n        const ptr = this.HEAPU32[this.ptr32 + 5];\n        return Int8Array.from(this.HEAP8.subarray(ptr, ptr + len));\n    }\n    get points() {\n        const len = this.HEAPU32[this.ptr32 + 7];\n        const ptr = this.HEAPU32[this.ptr32 + 8];\n        const ptr32 = ptr >> 2;\n        const res = [];\n        for (let i = 0; i < len; ++i) {\n            const x = this.HEAP32[ptr32 + i * 2];\n            const y = this.HEAP32[ptr32 + i * 2 + 1];\n            res.push({ x, y });\n        }\n        return res;\n    }\n    get next() {\n        const ptr = this.HEAPU32[this.ptr32 + 11];\n        if (!ptr)\n            return null;\n        return new SymbolPtr(ptr, this.buf);\n    }\n    get time() {\n        return this.HEAPU32[this.ptr32 + 13];\n    }\n    get cacheCount() {\n        return this.HEAP32[this.ptr32 + 14];\n    }\n    get quality() {\n        return this.HEAP32[this.ptr32 + 15];\n    }\n}\nclass SymbolSetPtr extends TypePointer {\n    get head() {\n        const ptr = this.HEAPU32[this.ptr32 + 2];\n        if (!ptr)\n            return null;\n        return new SymbolPtr(ptr, this.buf);\n    }\n}\nclass Symbol {\n    constructor(ptr) {\n        this.type = ptr.type;\n        this.typeName = enum_1.ZBarSymbolType[this.type];\n        this.data = ptr.data;\n        this.points = ptr.points;\n        this.time = ptr.time;\n        this.cacheCount = ptr.cacheCount;\n        this.quality = ptr.quality;\n    }\n    static createSymbolsFromPtr(ptr, buf) {\n        if (ptr == 0)\n            return [];\n        const set = new SymbolSetPtr(ptr, buf);\n        let symbol = set.head;\n        const res = [];\n        while (symbol !== null) {\n            res.push(new Symbol(symbol));\n            symbol = symbol.next;\n        }\n        return res;\n    }\n    decode(encoding) {\n        const decoder = new TextDecoder(encoding);\n        return decoder.decode(this.data);\n    }\n}\nexports.Symbol = Symbol;\n//# sourceMappingURL=Symbol.js.map"]},"metadata":{},"sourceType":"script"}