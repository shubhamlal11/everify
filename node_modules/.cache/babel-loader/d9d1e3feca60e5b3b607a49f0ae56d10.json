{"ast":null,"code":"/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst constants = require('../constants');\n\nconst jsonld = require('jsonld');\n\nconst ProofPurpose = require('./ProofPurpose');\n\nmodule.exports = class ControllerProofPurpose extends ProofPurpose {\n  /**\n   * Creates a proof purpose that will validate whether or not the verification\n   * method in a proof was authorized by its declared controller for the\n   * proof's purpose.\n   *\n   * @param term {string} the `proofPurpose` term, as defined in the\n   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.\n   * @param [controller] {object} the description of the controller, if it\n   *   is not to be dereferenced via a `documentLoader`.\n   * @param [date] {string or Date or integer} the expected date for\n   *   the creation of the proof.\n   * @param [maxTimestampDelta] {integer} a maximum number of seconds that\n   *   the date on the signature can deviate from, defaults to `Infinity`.\n   */\n  constructor() {\n    let {\n      term,\n      controller,\n      date,\n      maxTimestampDelta = Infinity\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({\n      term,\n      date,\n      maxTimestampDelta\n    });\n\n    if (controller !== undefined) {\n      if (typeof controller !== 'object') {\n        throw new TypeError('\"controller\" must be an object.');\n      }\n\n      this.controller = controller;\n    }\n  }\n  /**\n   * Validates the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (e.g. in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param proof\n   * @param verificationMethod\n   * @param documentLoader\n   * @param expansionMap\n   *\n   * @throws {Error} If verification method not authorized by controller\n   * @throws {Error} If proof's created timestamp is out of range\n   *\n   * @returns {Promise<{valid: boolean, error: Error}>}\n   */\n\n\n  async validate(proof, _ref) {\n    let {\n      verificationMethod,\n      documentLoader,\n      expansionMap\n    } = _ref;\n\n    try {\n      const result = await super.validate(proof, {\n        verificationMethod,\n        documentLoader,\n        expansionMap\n      });\n\n      if (!result.valid) {\n        throw result.error;\n      }\n\n      const {\n        id: verificationId\n      } = verificationMethod; // if no `controller` specified, use verification method's\n\n      if (this.controller) {\n        result.controller = this.controller;\n      } else {\n        // support legacy `owner` property\n        const {\n          controller,\n          owner\n        } = verificationMethod;\n        let controllerId;\n\n        if (controller) {\n          if (typeof controller === 'object') {\n            controllerId = controller.id;\n          } else if (typeof controller !== 'string') {\n            throw new TypeError('\"controller\" must be a string representing a URL.');\n          } else {\n            controllerId = controller;\n          }\n        } else if (owner) {\n          if (typeof owner === 'object') {\n            controllerId = owner.id;\n          } else if (typeof owner !== 'string') {\n            throw new TypeError('\"owner\" must be a string representing a URL.');\n          } else {\n            controllerId = owner;\n          }\n        } // Note: `expansionMap` is intentionally not passed; we can safely drop\n        // properties here and must allow for it\n\n\n        const {\n          '@graph': [framed = {}]\n        } = await jsonld.frame(controllerId, {\n          '@context': constants.SECURITY_CONTEXT_URL,\n          id: controllerId,\n          // the term should be in the json-ld object the controllerId resolves\n          // to.\n          [this.term]: {\n            '@embed': '@never',\n            id: verificationId\n          }\n        }, {\n          documentLoader,\n          compactToRelative: false\n        });\n        result.controller = framed;\n      }\n\n      const verificationMethods = jsonld.getValues(result.controller, this.term);\n      result.valid = verificationMethods.some(vm => vm === verificationId || typeof vm === 'object' && vm.id === verificationId);\n\n      if (!result.valid) {\n        throw new Error(`Verification method \"${verificationMethod.id}\" not authorized ` + `by controller for proof purpose \"${this.term}\".`);\n      }\n\n      return result;\n    } catch (error) {\n      return {\n        valid: false,\n        error\n      };\n    }\n  }\n\n};","map":{"version":3,"sources":["/Users/shubhamlal/Desktop/verification/node_modules/jsonld-signatures/lib/purposes/ControllerProofPurpose.js"],"names":["constants","require","jsonld","ProofPurpose","module","exports","ControllerProofPurpose","constructor","term","controller","date","maxTimestampDelta","Infinity","undefined","TypeError","validate","proof","verificationMethod","documentLoader","expansionMap","result","valid","error","id","verificationId","owner","controllerId","framed","frame","SECURITY_CONTEXT_URL","compactToRelative","verificationMethods","getValues","some","vm","Error"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst constants = require('../constants');\nconst jsonld = require('jsonld');\nconst ProofPurpose = require('./ProofPurpose');\n\nmodule.exports = class ControllerProofPurpose extends ProofPurpose {\n  /**\n   * Creates a proof purpose that will validate whether or not the verification\n   * method in a proof was authorized by its declared controller for the\n   * proof's purpose.\n   *\n   * @param term {string} the `proofPurpose` term, as defined in the\n   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.\n   * @param [controller] {object} the description of the controller, if it\n   *   is not to be dereferenced via a `documentLoader`.\n   * @param [date] {string or Date or integer} the expected date for\n   *   the creation of the proof.\n   * @param [maxTimestampDelta] {integer} a maximum number of seconds that\n   *   the date on the signature can deviate from, defaults to `Infinity`.\n   */\n  constructor({term, controller, date, maxTimestampDelta = Infinity} = {}) {\n    super({term, date, maxTimestampDelta});\n    if(controller !== undefined) {\n      if(typeof controller !== 'object') {\n        throw new TypeError('\"controller\" must be an object.');\n      }\n      this.controller = controller;\n    }\n  }\n\n  /**\n   * Validates the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (e.g. in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param proof\n   * @param verificationMethod\n   * @param documentLoader\n   * @param expansionMap\n   *\n   * @throws {Error} If verification method not authorized by controller\n   * @throws {Error} If proof's created timestamp is out of range\n   *\n   * @returns {Promise<{valid: boolean, error: Error}>}\n   */\n  async validate(proof, {verificationMethod, documentLoader, expansionMap}) {\n    try {\n      const result = await super.validate(\n        proof, {verificationMethod, documentLoader, expansionMap});\n      if(!result.valid) {\n        throw result.error;\n      }\n\n      const {id: verificationId} = verificationMethod;\n\n      // if no `controller` specified, use verification method's\n      if(this.controller) {\n        result.controller = this.controller;\n      } else {\n        // support legacy `owner` property\n        const {controller, owner} = verificationMethod;\n        let controllerId;\n        if(controller) {\n          if(typeof controller === 'object') {\n            controllerId = controller.id;\n          } else if(typeof controller !== 'string') {\n            throw new TypeError(\n              '\"controller\" must be a string representing a URL.');\n          } else {\n            controllerId = controller;\n          }\n        } else if(owner) {\n          if(typeof owner === 'object') {\n            controllerId = owner.id;\n          } else if(typeof owner !== 'string') {\n            throw new TypeError(\n              '\"owner\" must be a string representing a URL.');\n          } else {\n            controllerId = owner;\n          }\n        }\n        // Note: `expansionMap` is intentionally not passed; we can safely drop\n        // properties here and must allow for it\n        const {'@graph': [framed = {}]} = await jsonld.frame(controllerId, {\n          '@context': constants.SECURITY_CONTEXT_URL,\n          id: controllerId,\n          // the term should be in the json-ld object the controllerId resolves\n          // to.\n          [this.term]: {\n            '@embed': '@never',\n            id: verificationId\n          }\n        }, {documentLoader, compactToRelative: false});\n        result.controller = framed;\n      }\n      const verificationMethods = jsonld.getValues(\n        result.controller, this.term);\n      result.valid = verificationMethods.some(vm =>\n        vm === verificationId ||\n        (typeof vm === 'object' && vm.id === verificationId));\n      if(!result.valid) {\n        throw new Error(\n          `Verification method \"${verificationMethod.id}\" not authorized ` +\n          `by controller for proof purpose \"${this.term}\".`);\n      }\n      return result;\n    } catch(error) {\n      return {valid: false, error};\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}