{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/shubhamlal/Desktop/verification/node_modules/@babel/runtime/regenerator/index.js\");\n\nvar _asyncToGenerator = require(\"/Users/shubhamlal/Desktop/verification/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"/Users/shubhamlal/Desktop/verification/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/Users/shubhamlal/Desktop/verification/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"/Users/shubhamlal/Desktop/verification/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"/Users/shubhamlal/Desktop/verification/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Image = void 0;\n\nvar CppObject_1 = require(\"./CppObject\");\n\nvar Symbol_1 = require(\"./Symbol\");\n\nvar instance_1 = require(\"./instance\");\n\nvar Image = /*#__PURE__*/function (_CppObject_1$CppObjec) {\n  _inherits(Image, _CppObject_1$CppObjec);\n\n  var _super = _createSuper(Image);\n\n  function Image() {\n    _classCallCheck(this, Image);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Image, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.checkAlive();\n\n      this.inst._Image_destory(this.ptr);\n\n      this.ptr = 0;\n    }\n  }, {\n    key: \"getSymbols\",\n    value: function getSymbols() {\n      this.checkAlive();\n\n      var res = this.inst._Image_get_symbols(this.ptr);\n\n      return Symbol_1.Symbol.createSymbolsFromPtr(res, this.inst.HEAPU8.buffer);\n    }\n  }], [{\n    key: \"createFromGrayBuffer\",\n    value: function () {\n      var _createFromGrayBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(width, height, dataBuf) {\n        var sequence_num,\n            inst,\n            heap,\n            data,\n            len,\n            buf,\n            ptr,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                sequence_num = _args.length > 3 && _args[3] !== undefined ? _args[3] : 0;\n                _context.next = 3;\n                return (0, instance_1.getInstance)();\n\n              case 3:\n                inst = _context.sent;\n                heap = inst.HEAPU8;\n                data = new Uint8Array(dataBuf);\n                len = width * height;\n\n                if (!(len !== data.byteLength)) {\n                  _context.next = 9;\n                  break;\n                }\n\n                throw Error('dataBuf does not match width and height');\n\n              case 9:\n                buf = inst._malloc(len);\n                heap.set(data, buf);\n                ptr = inst._Image_create(width, height, 0x30303859\n                /* Y800 */\n                , buf, len, sequence_num);\n                return _context.abrupt(\"return\", new this(ptr, inst));\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function createFromGrayBuffer(_x, _x2, _x3) {\n        return _createFromGrayBuffer.apply(this, arguments);\n      }\n\n      return createFromGrayBuffer;\n    }()\n  }, {\n    key: \"createFromRGBABuffer\",\n    value: function () {\n      var _createFromRGBABuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(width, height, dataBuf) {\n        var sequence_num,\n            inst,\n            heap,\n            data,\n            len,\n            buf,\n            i,\n            r,\n            g,\n            b,\n            ptr,\n            _args2 = arguments;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                sequence_num = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : 0;\n                _context2.next = 3;\n                return (0, instance_1.getInstance)();\n\n              case 3:\n                inst = _context2.sent;\n                heap = inst.HEAPU8;\n                data = new Uint8Array(dataBuf);\n                len = width * height;\n\n                if (!(len * 4 !== data.byteLength)) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                throw Error('dataBuf does not match width and height');\n\n              case 9:\n                buf = inst._malloc(len);\n\n                for (i = 0; i < len; ++i) {\n                  r = data[i * 4];\n                  g = data[i * 4 + 1];\n                  b = data[i * 4 + 2];\n                  heap[buf + i] = r * 19595 + g * 38469 + b * 7472 >> 16;\n                }\n\n                ptr = inst._Image_create(width, height, 0x30303859\n                /* Y800 */\n                , buf, len, sequence_num);\n                return _context2.abrupt(\"return\", new this(ptr, inst));\n\n              case 13:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function createFromRGBABuffer(_x4, _x5, _x6) {\n        return _createFromRGBABuffer.apply(this, arguments);\n      }\n\n      return createFromRGBABuffer;\n    }()\n  }]);\n\n  return Image;\n}(CppObject_1.CppObject);\n\nexports.Image = Image;","map":{"version":3,"sources":["../src/Image.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Image = void 0;\nconst CppObject_1 = require(\"./CppObject\");\nconst Symbol_1 = require(\"./Symbol\");\nconst instance_1 = require(\"./instance\");\nclass Image extends CppObject_1.CppObject {\n    static async createFromGrayBuffer(width, height, dataBuf, sequence_num = 0) {\n        const inst = await (0, instance_1.getInstance)();\n        const heap = inst.HEAPU8;\n        const data = new Uint8Array(dataBuf);\n        const len = width * height;\n        if (len !== data.byteLength) {\n            throw Error('dataBuf does not match width and height');\n        }\n        const buf = inst._malloc(len);\n        heap.set(data, buf);\n        const ptr = inst._Image_create(width, height, 0x30303859 /* Y800 */, buf, len, sequence_num);\n        return new this(ptr, inst);\n    }\n    static async createFromRGBABuffer(width, height, dataBuf, sequence_num = 0) {\n        const inst = await (0, instance_1.getInstance)();\n        const heap = inst.HEAPU8;\n        const data = new Uint8Array(dataBuf);\n        const len = width * height;\n        if (len * 4 !== data.byteLength) {\n            throw Error('dataBuf does not match width and height');\n        }\n        const buf = inst._malloc(len);\n        for (let i = 0; i < len; ++i) {\n            const r = data[i * 4];\n            const g = data[i * 4 + 1];\n            const b = data[i * 4 + 2];\n            heap[buf + i] = (r * 19595 + g * 38469 + b * 7472) >> 16;\n        }\n        const ptr = inst._Image_create(width, height, 0x30303859 /* Y800 */, buf, len, sequence_num);\n        return new this(ptr, inst);\n    }\n    destroy() {\n        this.checkAlive();\n        this.inst._Image_destory(this.ptr);\n        this.ptr = 0;\n    }\n    getSymbols() {\n        this.checkAlive();\n        const res = this.inst._Image_get_symbols(this.ptr);\n        return Symbol_1.Symbol.createSymbolsFromPtr(res, this.inst.HEAPU8.buffer);\n    }\n}\nexports.Image = Image;\n//# sourceMappingURL=Image.js.map"]},"metadata":{},"sourceType":"script"}