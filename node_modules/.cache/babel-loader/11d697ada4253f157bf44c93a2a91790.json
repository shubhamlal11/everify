{"ast":null,"code":"/*!\n * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst env = require('../env');\n\nconst forge = require('node-forge');\n\nconst LinkedDataSignature = require('./LinkedDataSignature');\n\nmodule.exports = class LinkedDataSignature2015 extends LinkedDataSignature {\n  /**\n   * Advanced optional parameters and overrides:\n   *\n   * @param [domain] {string} domain to include in the signature.\n   * @param [nonce] {string} nonce to include in the signature.\n   * @param [useNativeCanonize] {boolean} true to use a native canonize\n   *   algorithm.\n   */\n  constructor() {\n    let {\n      type = 'LinkedDataSignature2015',\n      privateKeyPem,\n      publicKeyPem,\n      creator,\n      date,\n      domain,\n      nonce,\n      useNativeCanonize\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (domain !== undefined && typeof domain !== 'string') {\n      throw new TypeError('\"domain\" must be a string.');\n    }\n\n    if (nonce !== undefined && typeof nonce !== 'string') {\n      throw new TypeError('\"nonce\" must be a string.');\n    }\n\n    super({\n      type,\n      creator,\n      date,\n      domain,\n      nonce,\n      useNativeCanonize\n    });\n    this.legacy = true;\n    this.privateKeyPem = privateKeyPem;\n    this.publicKeyPem = publicKeyPem;\n    this.nonce = nonce;\n    this.domain = domain;\n  }\n  /**\n   * @param document {object} to be signed.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n\n\n  async updateProof(_ref) {\n    let {\n      proof\n    } = _ref;\n\n    if (this.domain !== undefined) {\n      proof.domain = this.domain;\n    }\n\n    if (this.nonce !== undefined) {\n      proof.nonce = this.nonce;\n    }\n\n    return proof;\n  }\n  /**\n   * @param proof {object} the proof to be verified.\n   * @param document {object} the document the proof applies to.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<{object}>} Resolves with the verification result.\n   */\n\n\n  async verifyProof(_ref2) {\n    let {\n      proof,\n      document,\n      purpose,\n      documentLoader,\n      expansionMap,\n      compactProof\n    } = _ref2;\n\n    try {\n      // check domain\n      if (this.domain !== undefined && proof.domain !== this.domain) {\n        throw new Error('The domain is not as expected; ' + `domain=\"${proof.domain}\", expected=\"${this.domain}\"`);\n      }\n\n      return super.verifyProof({\n        proof,\n        document,\n        purpose,\n        documentLoader,\n        expansionMap,\n        compactProof\n      });\n    } catch (error) {\n      return {\n        verified: false,\n        error\n      };\n    }\n  }\n  /**\n   * @param document {object} to be signed/verified.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<{Uint8Array}>}.\n   */\n\n\n  async createVerifyData(_ref3) {\n    let {\n      document,\n      proof,\n      documentLoader,\n      expansionMap\n    } = _ref3;\n    const c14n = await this.canonize(document, {\n      documentLoader,\n      expansionMap\n    });\n    let verifyData = '';\n    const headers = {\n      'http://purl.org/dc/elements/1.1/created': proof.created,\n      'https://w3id.org/security#domain': proof.domain,\n      'https://w3id.org/security#nonce': proof.nonce\n    }; // add headers in lexicographical order\n\n    const keys = Object.keys(headers).sort();\n\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      const value = headers[key];\n\n      if (!(value === null || value === undefined)) {\n        verifyData += key + ': ' + value + '\\n';\n      }\n    }\n\n    verifyData += c14n;\n    const buffer = new forge.util.ByteBuffer(verifyData, 'utf8');\n    return forge.util.binary.raw.decode(buffer.getBytes());\n  }\n\n  async sign(_ref4) {\n    let {\n      verifyData,\n      proof\n    } = _ref4;\n    const {\n      privateKeyPem\n    } = this;\n\n    if (typeof privateKeyPem !== 'string') {\n      throw new TypeError('\"privateKeyPem\" must be a PEM formatted string.');\n    }\n\n    let signature;\n\n    if (env.nodejs) {\n      // optimize using node libraries\n      const crypto = require('crypto');\n\n      const signer = crypto.createSign('RSA-SHA256');\n      signer.update(Buffer.from(verifyData.buffer, verifyData.byteOffset, verifyData.length));\n      signature = signer.sign(privateKeyPem, 'base64');\n    } else {\n      // browser or other environment\n      const privateKey = forge.pki.privateKeyFromPem(privateKeyPem);\n      const md = forge.md.sha256.create();\n      md.update(forge.util.binary.raw.encode(verifyData), 'binary');\n      signature = forge.util.encode64(privateKey.sign(md));\n    }\n\n    proof.signatureValue = signature;\n    return proof;\n  }\n\n  async verifySignature(_ref5) {\n    let {\n      verifyData,\n      proof\n    } = _ref5;\n    const {\n      publicKeyPem\n    } = this;\n\n    if (typeof publicKeyPem !== 'string') {\n      throw new TypeError('Could not verify signature; invalid \"publicKeyPem\".');\n    }\n\n    if (env.nodejs) {\n      // optimize using node libraries\n      const crypto = require('crypto');\n\n      const verifier = crypto.createVerify('RSA-SHA256');\n      verifier.update(Buffer.from(verifyData.buffer, verifyData.byteOffset, verifyData.length));\n      return verifier.verify(publicKeyPem, proof.signatureValue, 'base64');\n    } // browser or other environment\n\n\n    const publicKey = forge.pki.publicKeyFromPem(publicKeyPem);\n    const md = forge.md.sha256.create();\n    md.update(forge.util.binary.raw.encode(verifyData), 'binary');\n\n    try {\n      return publicKey.verify(md.digest().bytes(), forge.util.decode64(proof.signatureValue));\n    } catch (e) {\n      // simply return false, do return information about malformed signature\n      return false;\n    }\n  }\n\n  async getVerificationMethod(_ref6) {\n    let {\n      proof,\n      documentLoader\n    } = _ref6;\n    const verificationMethod = await super.getVerificationMethod({\n      proof,\n      documentLoader\n    });\n\n    if (!this.publicKeyPem) {\n      this.publicKeyPem = verificationMethod.publicKeyPem;\n    }\n\n    return verificationMethod;\n  }\n\n};","map":{"version":3,"sources":["/Users/shubhamlal/Desktop/verification/node_modules/jsonld-signatures/lib/suites/LinkedDataSignature2015.js"],"names":["env","require","forge","LinkedDataSignature","module","exports","LinkedDataSignature2015","constructor","type","privateKeyPem","publicKeyPem","creator","date","domain","nonce","useNativeCanonize","undefined","TypeError","legacy","updateProof","proof","verifyProof","document","purpose","documentLoader","expansionMap","compactProof","Error","error","verified","createVerifyData","c14n","canonize","verifyData","headers","created","keys","Object","sort","i","length","key","value","buffer","util","ByteBuffer","binary","raw","decode","getBytes","sign","signature","nodejs","crypto","signer","createSign","update","Buffer","from","byteOffset","privateKey","pki","privateKeyFromPem","md","sha256","create","encode","encode64","signatureValue","verifySignature","verifier","createVerify","verify","publicKey","publicKeyFromPem","digest","bytes","decode64","e","getVerificationMethod","verificationMethod"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst env = require('../env');\nconst forge = require('node-forge');\nconst LinkedDataSignature = require('./LinkedDataSignature');\n\nmodule.exports = class LinkedDataSignature2015 extends LinkedDataSignature {\n  /**\n   * Advanced optional parameters and overrides:\n   *\n   * @param [domain] {string} domain to include in the signature.\n   * @param [nonce] {string} nonce to include in the signature.\n   * @param [useNativeCanonize] {boolean} true to use a native canonize\n   *   algorithm.\n   */\n  constructor({\n    type = 'LinkedDataSignature2015',\n    privateKeyPem, publicKeyPem, creator, date, domain, nonce,\n    useNativeCanonize} = {}) {\n    if(domain !== undefined && typeof domain !== 'string') {\n      throw new TypeError('\"domain\" must be a string.');\n    }\n    if(nonce !== undefined && typeof nonce !== 'string') {\n      throw new TypeError('\"nonce\" must be a string.');\n    }\n    super({type, creator, date, domain, nonce, useNativeCanonize});\n    this.legacy = true;\n    this.privateKeyPem = privateKeyPem;\n    this.publicKeyPem = publicKeyPem;\n    this.nonce = nonce;\n    this.domain = domain;\n  }\n\n  /**\n   * @param document {object} to be signed.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async updateProof({proof}) {\n    if(this.domain !== undefined) {\n      proof.domain = this.domain;\n    }\n    if(this.nonce !== undefined) {\n      proof.nonce = this.nonce;\n    }\n    return proof;\n  }\n\n  /**\n   * @param proof {object} the proof to be verified.\n   * @param document {object} the document the proof applies to.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<{object}>} Resolves with the verification result.\n   */\n  async verifyProof({\n    proof, document, purpose, documentLoader, expansionMap,\n    compactProof}) {\n    try {\n      // check domain\n      if(this.domain !== undefined && proof.domain !== this.domain) {\n        throw new Error('The domain is not as expected; ' +\n          `domain=\"${proof.domain}\", expected=\"${this.domain}\"`);\n      }\n\n      return super.verifyProof({\n        proof, document, purpose, documentLoader, expansionMap,\n        compactProof});\n    } catch(error) {\n      return {verified: false, error};\n    }\n  }\n\n  /**\n   * @param document {object} to be signed/verified.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<{Uint8Array}>}.\n   */\n  async createVerifyData({\n    document, proof, documentLoader, expansionMap}) {\n    const c14n = await this.canonize(document, {\n      documentLoader,\n      expansionMap\n    });\n\n    let verifyData = '';\n    const headers = {\n      'http://purl.org/dc/elements/1.1/created': proof.created,\n      'https://w3id.org/security#domain': proof.domain,\n      'https://w3id.org/security#nonce': proof.nonce\n    };\n    // add headers in lexicographical order\n    const keys = Object.keys(headers).sort();\n    for(let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      const value = headers[key];\n      if(!(value === null || value === undefined)) {\n        verifyData += key + ': ' + value + '\\n';\n      }\n    }\n    verifyData += c14n;\n    const buffer = new forge.util.ByteBuffer(verifyData, 'utf8');\n    return forge.util.binary.raw.decode(buffer.getBytes());\n  }\n\n  async sign({verifyData, proof}) {\n    const {privateKeyPem} = this;\n    if(typeof privateKeyPem !== 'string') {\n      throw new TypeError('\"privateKeyPem\" must be a PEM formatted string.');\n    }\n\n    let signature;\n    if(env.nodejs) {\n      // optimize using node libraries\n      const crypto = require('crypto');\n      const signer = crypto.createSign('RSA-SHA256');\n      signer.update(Buffer.from(\n        verifyData.buffer, verifyData.byteOffset, verifyData.length));\n      signature = signer.sign(privateKeyPem, 'base64');\n    } else {\n      // browser or other environment\n      const privateKey = forge.pki.privateKeyFromPem(privateKeyPem);\n      const md = forge.md.sha256.create();\n      md.update(forge.util.binary.raw.encode(verifyData), 'binary');\n      signature = forge.util.encode64(privateKey.sign(md));\n    }\n\n    proof.signatureValue = signature;\n    return proof;\n  }\n\n  async verifySignature({verifyData, proof}) {\n    const {publicKeyPem} = this;\n    if(typeof publicKeyPem !== 'string') {\n      throw new TypeError(\n        'Could not verify signature; invalid \"publicKeyPem\".');\n    }\n\n    if(env.nodejs) {\n      // optimize using node libraries\n      const crypto = require('crypto');\n      const verifier = crypto.createVerify('RSA-SHA256');\n      verifier.update(Buffer.from(\n        verifyData.buffer, verifyData.byteOffset, verifyData.length));\n      return verifier.verify(publicKeyPem, proof.signatureValue, 'base64');\n    }\n\n    // browser or other environment\n    const publicKey = forge.pki.publicKeyFromPem(publicKeyPem);\n    const md = forge.md.sha256.create();\n    md.update(forge.util.binary.raw.encode(verifyData), 'binary');\n    try {\n      return publicKey.verify(\n        md.digest().bytes(), forge.util.decode64(proof.signatureValue));\n    } catch(e) {\n      // simply return false, do return information about malformed signature\n      return false;\n    }\n  }\n\n  async getVerificationMethod({proof, documentLoader}) {\n    const verificationMethod = await super.getVerificationMethod(\n      {proof, documentLoader});\n    if(!this.publicKeyPem) {\n      this.publicKeyPem = verificationMethod.publicKeyPem;\n    }\n    return verificationMethod;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}