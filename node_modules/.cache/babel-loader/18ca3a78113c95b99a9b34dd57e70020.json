{"ast":null,"code":"/*!\n * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst constants = require('../constants');\n\nconst jsonld = require('jsonld');\n\nconst util = require('../util');\n\nconst LinkedDataProof = require('./LinkedDataProof');\n\nmodule.exports = class LinkedDataSignature extends LinkedDataProof {\n  /**\n   * @param type {string} Provided by subclass.\n   *\n   * One of these parameters is required to use a suite for signing:\n   *\n   * @param [creator] {string} A key id URL to the paired public key.\n   * @param [verificationMethod] {string} A key id URL to the paired public key.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param [proof] {object} a JSON-LD document with options to use for\n   *   the `proof` node (e.g. any other custom fields can be provided here\n   *   using a context different from security-v2).\n   * @param [date] {string|Date} signing date to use if not passed.\n   * @param [useNativeCanonize] {boolean} true to use a native canonize\n   *   algorithm.\n   */\n  constructor() {\n    let {\n      type,\n      creator,\n      verificationMethod,\n      proof,\n      date,\n      useNativeCanonize\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    // validate common options\n    if (verificationMethod !== undefined && typeof verificationMethod !== 'string') {\n      throw new TypeError('\"verificationMethod\" must be a URL string.');\n    }\n\n    super({\n      type\n    });\n    this.creator = creator;\n    this.verificationMethod = verificationMethod;\n    this.proof = proof;\n\n    if (date !== undefined) {\n      this.date = new Date(date);\n\n      if (isNaN(this.date)) {\n        throw TypeError(`\"date\" \"${date}\" is not a valid date.`);\n      }\n    }\n\n    this.useNativeCanonize = useNativeCanonize;\n  }\n  /**\n   * @param document {object} to be signed.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n\n\n  async createProof(_ref) {\n    let {\n      document,\n      purpose,\n      documentLoader,\n      expansionMap,\n      compactProof\n    } = _ref;\n    // build proof (currently known as `signature options` in spec)\n    let proof;\n\n    if (this.proof) {\n      // use proof JSON-LD document passed to API\n      proof = await jsonld.compact(this.proof, constants.SECURITY_CONTEXT_URL, {\n        documentLoader,\n        expansionMap,\n        compactToRelative: false\n      });\n    } else {\n      // create proof JSON-LD document\n      proof = {\n        '@context': constants.SECURITY_CONTEXT_URL\n      };\n    } // ensure proof type is set\n\n\n    proof.type = this.type; // set default `now` date if not given in `proof` or `options`\n\n    let date = this.date;\n\n    if (proof.created === undefined && date === undefined) {\n      date = new Date();\n    } // ensure date is in string format\n\n\n    if (date !== undefined && typeof date !== 'string') {\n      date = util.w3cDate(date);\n    } // add API overrides\n\n\n    if (date !== undefined) {\n      proof.created = date;\n    } // `verificationMethod` is for newer suites, `creator` for legacy\n\n\n    if (this.verificationMethod !== undefined) {\n      proof.verificationMethod = this.verificationMethod;\n    }\n\n    if (this.creator !== undefined) {\n      proof.creator = this.creator;\n    } // add any extensions to proof (mostly for legacy support)\n\n\n    proof = await this.updateProof({\n      document,\n      proof,\n      purpose,\n      documentLoader,\n      expansionMap,\n      compactProof\n    }); // allow purpose to update the proof; the `proof` is in the\n    // SECURITY_CONTEXT_URL `@context` -- therefore the `purpose` must\n    // ensure any added fields are also represented in that same `@context`\n\n    proof = await purpose.update(proof, {\n      document,\n      suite: this,\n      documentLoader,\n      expansionMap\n    }); // create data to sign\n\n    const verifyData = await this.createVerifyData({\n      document,\n      proof,\n      documentLoader,\n      expansionMap,\n      compactProof\n    }); // sign data\n\n    proof = await this.sign({\n      verifyData,\n      document,\n      proof,\n      documentLoader,\n      expansionMap\n    });\n    return proof;\n  }\n  /**\n   * @param document {object} to be signed.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n\n\n  async updateProof(_ref2) {\n    let {\n      proof\n    } = _ref2;\n    // extending classes may do more\n    return proof;\n  }\n  /**\n   * @param proof {object} the proof to be verified.\n   * @param document {object} the document the proof applies to.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<{object}>} Resolves with the verification result.\n   */\n\n\n  async verifyProof(_ref3) {\n    let {\n      proof,\n      document,\n      purpose,\n      documentLoader,\n      expansionMap,\n      compactProof\n    } = _ref3;\n\n    try {\n      // create data to verify\n      const verifyData = await this.createVerifyData({\n        document,\n        proof,\n        documentLoader,\n        expansionMap,\n        compactProof\n      }); // fetch verification method\n\n      const verificationMethod = await this.getVerificationMethod({\n        proof,\n        document,\n        documentLoader,\n        expansionMap\n      }); // verify signature on data\n\n      const verified = await this.verifySignature({\n        verifyData,\n        verificationMethod,\n        document,\n        proof,\n        documentLoader,\n        expansionMap\n      });\n\n      if (!verified) {\n        throw new Error('Invalid signature.');\n      } // ensure proof was performed for a valid purpose\n\n\n      const purposeResult = await purpose.validate(proof, {\n        document,\n        suite: this,\n        verificationMethod,\n        documentLoader,\n        expansionMap\n      });\n\n      if (!purposeResult.valid) {\n        throw purposeResult.error;\n      }\n\n      return {\n        verified: true,\n        purposeResult\n      };\n    } catch (error) {\n      return {\n        verified: false,\n        error\n      };\n    }\n  }\n\n  async canonize(input, _ref4) {\n    let {\n      documentLoader,\n      expansionMap,\n      skipExpansion\n    } = _ref4;\n    return jsonld.canonize(input, {\n      algorithm: 'URDNA2015',\n      format: 'application/n-quads',\n      documentLoader,\n      expansionMap,\n      skipExpansion,\n      useNative: this.useNativeCanonize\n    });\n  }\n\n  async canonizeProof(proof, _ref5) {\n    let {\n      documentLoader,\n      expansionMap\n    } = _ref5;\n    // `jws`,`signatureValue`,`proofValue` must not be included in the proof\n    // options\n    proof = { ...proof\n    };\n    delete proof.jws;\n    delete proof.signatureValue;\n    delete proof.proofValue;\n    return this.canonize(proof, {\n      documentLoader,\n      expansionMap,\n      skipExpansion: false\n    });\n  }\n  /**\n   * @param document {object} to be signed/verified.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<{Uint8Array}>}.\n   */\n\n\n  async createVerifyData(_ref6) {\n    let {\n      document,\n      proof,\n      documentLoader,\n      expansionMap\n    } = _ref6;\n    // concatenate hash of c14n proof options and hash of c14n document\n    const c14nProofOptions = await this.canonizeProof(proof, {\n      documentLoader,\n      expansionMap\n    });\n    const c14nDocument = await this.canonize(document, {\n      documentLoader,\n      expansionMap\n    });\n    return util.concat(util.sha256(c14nProofOptions), util.sha256(c14nDocument));\n  }\n  /**\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   */\n\n\n  async getVerificationMethod(_ref7) {\n    let {\n      proof,\n      documentLoader\n    } = _ref7;\n    let {\n      verificationMethod\n    } = proof;\n\n    if (!verificationMethod) {\n      // backwards compatibility support for `creator`\n      const {\n        creator\n      } = proof;\n      verificationMethod = creator;\n    }\n\n    if (typeof verificationMethod === 'object') {\n      verificationMethod = verificationMethod.id;\n    }\n\n    if (!verificationMethod) {\n      throw new Error('No \"verificationMethod\" or \"creator\" found in proof.');\n    } // Note: `expansionMap` is intentionally not passed; we can safely drop\n    // properties here and must allow for it\n\n\n    const {\n      '@graph': [framed]\n    } = await jsonld.frame(verificationMethod, {\n      '@context': constants.SECURITY_CONTEXT_URL,\n      '@embed': '@always',\n      id: verificationMethod\n    }, {\n      documentLoader,\n      compactToRelative: false\n    });\n\n    if (!framed) {\n      throw new Error(`Verification method ${verificationMethod} not found.`);\n    } // ensure verification method has not been revoked\n\n\n    if (framed.revoked !== undefined) {\n      throw new Error('The verification method has been revoked.');\n    }\n\n    return framed;\n  }\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{object}>} the proof containing the signature value.\n   */\n\n\n  async sign() {\n    throw new Error('Must be implemented by a derived class.');\n  }\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param verificationMethod {object}.\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<boolean>}\n   */\n\n\n  async verifySignature() {\n    throw new Error('Must be implemented by a derived class.');\n  }\n\n};","map":{"version":3,"sources":["/Users/shubhamlal/Desktop/verification/node_modules/jsonld-signatures/lib/suites/LinkedDataSignature.js"],"names":["constants","require","jsonld","util","LinkedDataProof","module","exports","LinkedDataSignature","constructor","type","creator","verificationMethod","proof","date","useNativeCanonize","undefined","TypeError","Date","isNaN","createProof","document","purpose","documentLoader","expansionMap","compactProof","compact","SECURITY_CONTEXT_URL","compactToRelative","created","w3cDate","updateProof","update","suite","verifyData","createVerifyData","sign","verifyProof","getVerificationMethod","verified","verifySignature","Error","purposeResult","validate","valid","error","canonize","input","skipExpansion","algorithm","format","useNative","canonizeProof","jws","signatureValue","proofValue","c14nProofOptions","c14nDocument","concat","sha256","id","framed","frame","revoked"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst constants = require('../constants');\nconst jsonld = require('jsonld');\nconst util = require('../util');\nconst LinkedDataProof = require('./LinkedDataProof');\n\nmodule.exports = class LinkedDataSignature extends LinkedDataProof {\n  /**\n   * @param type {string} Provided by subclass.\n   *\n   * One of these parameters is required to use a suite for signing:\n   *\n   * @param [creator] {string} A key id URL to the paired public key.\n   * @param [verificationMethod] {string} A key id URL to the paired public key.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param [proof] {object} a JSON-LD document with options to use for\n   *   the `proof` node (e.g. any other custom fields can be provided here\n   *   using a context different from security-v2).\n   * @param [date] {string|Date} signing date to use if not passed.\n   * @param [useNativeCanonize] {boolean} true to use a native canonize\n   *   algorithm.\n   */\n  constructor({\n    type, creator, verificationMethod, proof, date,\n    useNativeCanonize} = {}) {\n    // validate common options\n    if(verificationMethod !== undefined &&\n      typeof verificationMethod !== 'string') {\n      throw new TypeError('\"verificationMethod\" must be a URL string.');\n    }\n    super({type});\n    this.creator = creator;\n    this.verificationMethod = verificationMethod;\n    this.proof = proof;\n    if(date !== undefined) {\n      this.date = new Date(date);\n      if(isNaN(this.date)) {\n        throw TypeError(`\"date\" \"${date}\" is not a valid date.`);\n      }\n    }\n    this.useNativeCanonize = useNativeCanonize;\n  }\n\n  /**\n   * @param document {object} to be signed.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async createProof(\n    {document, purpose, documentLoader, expansionMap, compactProof}) {\n    // build proof (currently known as `signature options` in spec)\n    let proof;\n    if(this.proof) {\n      // use proof JSON-LD document passed to API\n      proof = await jsonld.compact(\n        this.proof, constants.SECURITY_CONTEXT_URL,\n        {documentLoader, expansionMap, compactToRelative: false});\n    } else {\n      // create proof JSON-LD document\n      proof = {'@context': constants.SECURITY_CONTEXT_URL};\n    }\n\n    // ensure proof type is set\n    proof.type = this.type;\n\n    // set default `now` date if not given in `proof` or `options`\n    let date = this.date;\n    if(proof.created === undefined && date === undefined) {\n      date = new Date();\n    }\n\n    // ensure date is in string format\n    if(date !== undefined && typeof date !== 'string') {\n      date = util.w3cDate(date);\n    }\n\n    // add API overrides\n    if(date !== undefined) {\n      proof.created = date;\n    }\n    // `verificationMethod` is for newer suites, `creator` for legacy\n    if(this.verificationMethod !== undefined) {\n      proof.verificationMethod = this.verificationMethod;\n    }\n    if(this.creator !== undefined) {\n      proof.creator = this.creator;\n    }\n\n    // add any extensions to proof (mostly for legacy support)\n    proof = await this.updateProof({\n      document, proof, purpose,\n      documentLoader, expansionMap, compactProof});\n\n    // allow purpose to update the proof; the `proof` is in the\n    // SECURITY_CONTEXT_URL `@context` -- therefore the `purpose` must\n    // ensure any added fields are also represented in that same `@context`\n    proof = await purpose.update(\n      proof, {document, suite: this, documentLoader, expansionMap});\n\n    // create data to sign\n    const verifyData = await this.createVerifyData(\n      {document, proof, documentLoader, expansionMap, compactProof});\n\n    // sign data\n    proof = await this.sign(\n      {verifyData, document, proof, documentLoader, expansionMap});\n\n    return proof;\n  }\n\n  /**\n   * @param document {object} to be signed.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async updateProof({proof}) {\n    // extending classes may do more\n    return proof;\n  }\n\n  /**\n   * @param proof {object} the proof to be verified.\n   * @param document {object} the document the proof applies to.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<{object}>} Resolves with the verification result.\n   */\n  async verifyProof({\n    proof, document, purpose, documentLoader, expansionMap,\n    compactProof}) {\n    try {\n      // create data to verify\n      const verifyData = await this.createVerifyData(\n        {document, proof, documentLoader, expansionMap, compactProof});\n\n      // fetch verification method\n      const verificationMethod = await this.getVerificationMethod(\n        {proof, document, documentLoader, expansionMap});\n\n      // verify signature on data\n      const verified = await this.verifySignature({\n        verifyData, verificationMethod, document, proof,\n        documentLoader, expansionMap});\n      if(!verified) {\n        throw new Error('Invalid signature.');\n      }\n\n      // ensure proof was performed for a valid purpose\n      const purposeResult = await purpose.validate(\n        proof, {document, suite: this, verificationMethod,\n          documentLoader, expansionMap});\n      if(!purposeResult.valid) {\n        throw purposeResult.error;\n      }\n\n      return {verified: true, purposeResult};\n    } catch(error) {\n      return {verified: false, error};\n    }\n  }\n\n  async canonize(input, {documentLoader, expansionMap, skipExpansion}) {\n    return jsonld.canonize(input, {\n      algorithm: 'URDNA2015',\n      format: 'application/n-quads',\n      documentLoader,\n      expansionMap,\n      skipExpansion,\n      useNative: this.useNativeCanonize\n    });\n  }\n\n  async canonizeProof(proof, {documentLoader, expansionMap}) {\n    // `jws`,`signatureValue`,`proofValue` must not be included in the proof\n    // options\n    proof = {...proof};\n    delete proof.jws;\n    delete proof.signatureValue;\n    delete proof.proofValue;\n    return this.canonize(proof, {\n      documentLoader,\n      expansionMap,\n      skipExpansion: false\n    });\n  }\n\n  /**\n   * @param document {object} to be signed/verified.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<{Uint8Array}>}.\n   */\n  async createVerifyData({\n    document, proof, documentLoader, expansionMap}) {\n    // concatenate hash of c14n proof options and hash of c14n document\n    const c14nProofOptions = await this.canonizeProof(\n      proof, {documentLoader, expansionMap});\n    const c14nDocument = await this.canonize(document, {\n      documentLoader,\n      expansionMap\n    });\n    return util.concat(\n      util.sha256(c14nProofOptions),\n      util.sha256(c14nDocument));\n  }\n\n  /**\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   */\n  async getVerificationMethod({proof, documentLoader}) {\n    let {verificationMethod} = proof;\n\n    if(!verificationMethod) {\n      // backwards compatibility support for `creator`\n      const {creator} = proof;\n      verificationMethod = creator;\n    }\n\n    if(typeof verificationMethod === 'object') {\n      verificationMethod = verificationMethod.id;\n    }\n\n    if(!verificationMethod) {\n      throw new Error('No \"verificationMethod\" or \"creator\" found in proof.');\n    }\n\n    // Note: `expansionMap` is intentionally not passed; we can safely drop\n    // properties here and must allow for it\n    const {'@graph': [framed]} = await jsonld.frame(verificationMethod, {\n      '@context': constants.SECURITY_CONTEXT_URL,\n      '@embed': '@always',\n      id: verificationMethod\n    }, {documentLoader, compactToRelative: false});\n    if(!framed) {\n      throw new Error(`Verification method ${verificationMethod} not found.`);\n    }\n\n    // ensure verification method has not been revoked\n    if(framed.revoked !== undefined) {\n      throw new Error('The verification method has been revoked.');\n    }\n\n    return framed;\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{object}>} the proof containing the signature value.\n   */\n  async sign() {\n    throw new Error('Must be implemented by a derived class.');\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param verificationMethod {object}.\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<boolean>}\n   */\n  async verifySignature() {\n    throw new Error('Must be implemented by a derived class.');\n  }\n};\n"]},"metadata":{},"sourceType":"script"}