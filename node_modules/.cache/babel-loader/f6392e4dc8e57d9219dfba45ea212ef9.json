{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {\n  parseLinkHeader,\n  buildHeaders\n} = require('../util');\n\nconst {\n  LINK_HEADER_REL\n} = require('../constants');\n\nconst JsonLdError = require('../JsonLdError');\n\nconst RequestQueue = require('../RequestQueue');\n/**\n * Creates a built-in node document loader.\n *\n * @param options the options to use:\n *          secure: require all URLs to use HTTPS.\n *          strictSSL: true to require SSL certificates to be valid,\n *            false not to (default: true).\n *          maxRedirects: the maximum number of redirects to permit, none by\n *            default.\n *          request: the object which will make the request, default is\n *            provided by `https://www.npmjs.com/package/request`.\n *          headers: an object (map) of headers which will be passed as request\n *            headers for the requested document. Accept is not allowed.\n *\n * @return the node document loader.\n */\n\n\nmodule.exports = function () {\n  let {\n    secure,\n    strictSSL = true,\n    maxRedirects = -1,\n    request,\n    headers = {}\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    strictSSL: true,\n    maxRedirects: -1,\n    headers: {}\n  };\n  headers = buildHeaders(headers); // TODO: use `axios`\n\n  request = request || require('request');\n\n  const http = require('http');\n\n  const queue = new RequestQueue();\n  return queue.wrapLoader(function (url) {\n    return loadDocument(url, []);\n  });\n\n  async function loadDocument(url, redirects) {\n    if (url.indexOf('http:') !== 0 && url.indexOf('https:') !== 0) {\n      throw new JsonLdError('URL could not be dereferenced; only \"http\" and \"https\" URLs are ' + 'supported.', 'jsonld.InvalidUrl', {\n        code: 'loading document failed',\n        url\n      });\n    }\n\n    if (secure && url.indexOf('https') !== 0) {\n      throw new JsonLdError('URL could not be dereferenced; secure mode is enabled and ' + 'the URL\\'s scheme is not \"https\".', 'jsonld.InvalidUrl', {\n        code: 'loading document failed',\n        url\n      });\n    } // TODO: disable cache until HTTP caching implemented\n\n\n    let doc = null; //cache.get(url);\n\n    if (doc !== null) {\n      return doc;\n    }\n\n    let result;\n\n    try {\n      result = await _request(request, {\n        url,\n        headers,\n        strictSSL,\n        followRedirect: false\n      });\n    } catch (e) {\n      throw new JsonLdError('URL could not be dereferenced, an error occurred.', 'jsonld.LoadDocumentError', {\n        code: 'loading document failed',\n        url,\n        cause: e\n      });\n    }\n\n    const {\n      res,\n      body\n    } = result;\n    doc = {\n      contextUrl: null,\n      documentUrl: url,\n      document: body || null\n    }; // handle error\n\n    const statusText = http.STATUS_CODES[res.statusCode];\n\n    if (res.statusCode >= 400) {\n      throw new JsonLdError(`URL \"${url}\" could not be dereferenced: ${statusText}`, 'jsonld.InvalidUrl', {\n        code: 'loading document failed',\n        url,\n        httpStatusCode: res.statusCode\n      });\n    } // handle Link Header\n\n\n    if (res.headers.link && res.headers['content-type'] !== 'application/ld+json') {\n      // only 1 related link header permitted\n      const linkHeader = parseLinkHeader(res.headers.link)[LINK_HEADER_REL];\n\n      if (Array.isArray(linkHeader)) {\n        throw new JsonLdError('URL could not be dereferenced, it has more than one associated ' + 'HTTP Link Header.', 'jsonld.InvalidUrl', {\n          code: 'multiple context link headers',\n          url\n        });\n      }\n\n      if (linkHeader) {\n        doc.contextUrl = linkHeader.target;\n      }\n    } // handle redirect\n\n\n    if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {\n      if (redirects.length === maxRedirects) {\n        throw new JsonLdError('URL could not be dereferenced; there were too many redirects.', 'jsonld.TooManyRedirects', {\n          code: 'loading document failed',\n          url,\n          httpStatusCode: res.statusCode,\n          redirects\n        });\n      }\n\n      if (redirects.indexOf(url) !== -1) {\n        throw new JsonLdError('URL could not be dereferenced; infinite redirection was detected.', 'jsonld.InfiniteRedirectDetected', {\n          code: 'recursive context inclusion',\n          url,\n          httpStatusCode: res.statusCode,\n          redirects\n        });\n      }\n\n      redirects.push(url);\n      return loadDocument(res.headers.location, redirects);\n    } // cache for each redirected URL\n\n\n    redirects.push(url); // TODO: disable cache until HTTP caching implemented\n\n    /*\n    for(let i = 0; i < redirects.length; ++i) {\n      cache.set(\n        redirects[i],\n        {contextUrl: null, documentUrl: redirects[i], document: body});\n    }\n    */\n\n    return doc;\n  }\n};\n\nfunction _request(request, options) {\n  return new Promise((resolve, reject) => {\n    request(options, (err, res, body) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve({\n          res,\n          body\n        });\n      }\n    });\n  });\n}","map":{"version":3,"sources":["/Users/shubhamlal/Desktop/verification/node_modules/jsonld/lib/documentLoaders/node.js"],"names":["parseLinkHeader","buildHeaders","require","LINK_HEADER_REL","JsonLdError","RequestQueue","module","exports","secure","strictSSL","maxRedirects","request","headers","http","queue","wrapLoader","url","loadDocument","redirects","indexOf","code","doc","result","_request","followRedirect","e","cause","res","body","contextUrl","documentUrl","document","statusText","STATUS_CODES","statusCode","httpStatusCode","link","linkHeader","Array","isArray","target","location","length","push","options","Promise","resolve","reject","err"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {parseLinkHeader, buildHeaders} = require('../util');\nconst {LINK_HEADER_REL} = require('../constants');\nconst JsonLdError = require('../JsonLdError');\nconst RequestQueue = require('../RequestQueue');\n\n/**\n * Creates a built-in node document loader.\n *\n * @param options the options to use:\n *          secure: require all URLs to use HTTPS.\n *          strictSSL: true to require SSL certificates to be valid,\n *            false not to (default: true).\n *          maxRedirects: the maximum number of redirects to permit, none by\n *            default.\n *          request: the object which will make the request, default is\n *            provided by `https://www.npmjs.com/package/request`.\n *          headers: an object (map) of headers which will be passed as request\n *            headers for the requested document. Accept is not allowed.\n *\n * @return the node document loader.\n */\nmodule.exports = ({\n  secure,\n  strictSSL = true,\n  maxRedirects = -1,\n  request,\n  headers = {}\n} = {strictSSL: true, maxRedirects: -1, headers: {}}) => {\n  headers = buildHeaders(headers);\n  // TODO: use `axios`\n  request = request || require('request');\n  const http = require('http');\n\n  const queue = new RequestQueue();\n  return queue.wrapLoader(function(url) {\n    return loadDocument(url, []);\n  });\n\n  async function loadDocument(url, redirects) {\n    if(url.indexOf('http:') !== 0 && url.indexOf('https:') !== 0) {\n      throw new JsonLdError(\n        'URL could not be dereferenced; only \"http\" and \"https\" URLs are ' +\n        'supported.',\n        'jsonld.InvalidUrl', {code: 'loading document failed', url});\n    }\n    if(secure && url.indexOf('https') !== 0) {\n      throw new JsonLdError(\n        'URL could not be dereferenced; secure mode is enabled and ' +\n        'the URL\\'s scheme is not \"https\".',\n        'jsonld.InvalidUrl', {code: 'loading document failed', url});\n    }\n    // TODO: disable cache until HTTP caching implemented\n    let doc = null;//cache.get(url);\n    if(doc !== null) {\n      return doc;\n    }\n\n    let result;\n    try {\n      result = await _request(request, {\n        url,\n        headers,\n        strictSSL,\n        followRedirect: false\n      });\n    } catch(e) {\n      throw new JsonLdError(\n        'URL could not be dereferenced, an error occurred.',\n        'jsonld.LoadDocumentError',\n        {code: 'loading document failed', url, cause: e});\n    }\n\n    const {res, body} = result;\n\n    doc = {contextUrl: null, documentUrl: url, document: body || null};\n\n    // handle error\n    const statusText = http.STATUS_CODES[res.statusCode];\n    if(res.statusCode >= 400) {\n      throw new JsonLdError(\n        `URL \"${url}\" could not be dereferenced: ${statusText}`,\n        'jsonld.InvalidUrl', {\n          code: 'loading document failed',\n          url,\n          httpStatusCode: res.statusCode\n        });\n    }\n\n    // handle Link Header\n    if(res.headers.link &&\n      res.headers['content-type'] !== 'application/ld+json') {\n      // only 1 related link header permitted\n      const linkHeader = parseLinkHeader(res.headers.link)[LINK_HEADER_REL];\n      if(Array.isArray(linkHeader)) {\n        throw new JsonLdError(\n          'URL could not be dereferenced, it has more than one associated ' +\n          'HTTP Link Header.',\n          'jsonld.InvalidUrl',\n          {code: 'multiple context link headers', url});\n      }\n      if(linkHeader) {\n        doc.contextUrl = linkHeader.target;\n      }\n    }\n\n    // handle redirect\n    if(res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {\n      if(redirects.length === maxRedirects) {\n        throw new JsonLdError(\n          'URL could not be dereferenced; there were too many redirects.',\n          'jsonld.TooManyRedirects', {\n            code: 'loading document failed',\n            url,\n            httpStatusCode: res.statusCode,\n            redirects\n          });\n      }\n      if(redirects.indexOf(url) !== -1) {\n        throw new JsonLdError(\n          'URL could not be dereferenced; infinite redirection was detected.',\n          'jsonld.InfiniteRedirectDetected', {\n            code: 'recursive context inclusion',\n            url,\n            httpStatusCode: res.statusCode,\n            redirects\n          });\n      }\n      redirects.push(url);\n      return loadDocument(res.headers.location, redirects);\n    }\n\n    // cache for each redirected URL\n    redirects.push(url);\n    // TODO: disable cache until HTTP caching implemented\n    /*\n    for(let i = 0; i < redirects.length; ++i) {\n      cache.set(\n        redirects[i],\n        {contextUrl: null, documentUrl: redirects[i], document: body});\n    }\n    */\n\n    return doc;\n  }\n};\n\nfunction _request(request, options) {\n  return new Promise((resolve, reject) => {\n    request(options, (err, res, body) => {\n      if(err) {\n        reject(err);\n      } else {\n        resolve({res, body});\n      }\n    });\n  });\n}\n"]},"metadata":{},"sourceType":"script"}