{"ast":null,"code":"/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst LinkedDataSignature = require('./LinkedDataSignature');\n\nconst jsonld = require('jsonld');\n\nconst util = require('../util');\n\nmodule.exports = class JwsLinkedDataSignature extends LinkedDataSignature {\n  /**\n   * @param type {string} Provided by subclass.\n   * @param alg {string} JWS alg provided by subclass.\n   * @param [LDKeyClass] {LDKeyClass} provided by subclass or subclass\n   *   overrides `getVerificationMethod`.\n   *\n   * One of these parameters is required to use a suite for signing:\n   *\n   * @param [creator] {string} A key id URL to the paired public key.\n   * @param [verificationMethod] {string} A key id URL to the paired public key.\n   *\n   * This parameter is required for signing:\n   *\n   * @param [signer] {function} an optional signer.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param [proof] {object} a JSON-LD document with options to use for\n   *   the `proof` node (e.g. any other custom fields can be provided here\n   *   using a context different from security-v2).\n   * @param [date] {string|Date} signing date to use if not passed.\n   * @param [key] {LDKeyPair} an optional crypto-ld KeyPair.\n   * @param [useNativeCanonize] {boolean} true to use a native canonize\n   *   algorithm.\n   */\n  constructor() {\n    let {\n      type,\n      alg,\n      LDKeyClass,\n      creator,\n      verificationMethod,\n      signer,\n      key,\n      proof,\n      date,\n      useNativeCanonize\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({\n      type,\n      creator,\n      verificationMethod,\n      proof,\n      date,\n      useNativeCanonize\n    });\n    this.alg = alg;\n    this.LDKeyClass = LDKeyClass;\n    this.signer = signer;\n\n    if (key) {\n      if (verificationMethod === undefined && creator === undefined) {\n        const publicKey = key.publicNode();\n\n        if (publicKey.owner) {\n          // use legacy signature terms\n          this.creator = publicKey.id;\n        } else {\n          // use newer signature terms\n          this.verificationMethod = publicKey.id;\n        }\n      }\n\n      this.key = key;\n\n      if (typeof key.signer === 'function') {\n        this.signer = key.signer();\n      }\n\n      if (typeof key.verifier === 'function') {\n        this.verifier = key.verifier();\n      }\n    }\n  }\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param proof {object}\n   *\n   * @returns {Promise<{object}>} the proof containing the signature value.\n   */\n\n\n  async sign(_ref) {\n    let {\n      verifyData,\n      proof\n    } = _ref;\n\n    if (!(this.signer && typeof this.signer.sign === 'function')) {\n      throw new Error('A signer API has not been specified.');\n    } // JWS header\n\n\n    const header = {\n      alg: this.alg,\n      b64: false,\n      crit: ['b64']\n    };\n    /*\n    +-------+-----------------------------------------------------------+\n    | \"b64\" | JWS Signing Input Formula                                 |\n    +-------+-----------------------------------------------------------+\n    | true  | ASCII(BASE64URL(UTF8(JWS Protected Header)) || '.' ||     |\n    |       | BASE64URL(JWS Payload))                                   |\n    |       |                                                           |\n    | false | ASCII(BASE64URL(UTF8(JWS Protected Header)) || '.') ||    |\n    |       | JWS Payload                                               |\n    +-------+-----------------------------------------------------------+\n    */\n    // create JWS data and sign\n\n    const encodedHeader = util.encodeBase64Url(JSON.stringify(header));\n    const data = util.createJws({\n      encodedHeader,\n      verifyData\n    });\n    const signature = await this.signer.sign({\n      data\n    }); // create detached content signature\n\n    const encodedSignature = util.encodeBase64Url(signature);\n    proof.jws = encodedHeader + '..' + encodedSignature;\n    return proof;\n  }\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param verificationMethod {object}.\n   * @param document {object} the document the proof applies to.\n   * @param proof {object} the proof to be verified.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{boolean}>} Resolves with the verification result.\n   */\n\n\n  async verifySignature(_ref2) {\n    let {\n      verifyData,\n      verificationMethod,\n      proof\n    } = _ref2;\n\n    if (!(proof.jws && typeof proof.jws === 'string' && proof.jws.includes('.'))) {\n      throw new TypeError('The proof does not include a valid \"jws\" property.');\n    } // add payload into detached content signature\n\n\n    const [\n      /*payload*/\n    encodedHeader,, encodedSignature] = proof.jws.split('.');\n    let header;\n\n    try {\n      header = JSON.parse(util.decodeBase64UrlToString(encodedHeader));\n    } catch (e) {\n      throw new Error('Could not parse JWS header; ' + e);\n    }\n\n    if (!(header && typeof header === 'object')) {\n      throw new Error('Invalid JWS header.');\n    } // confirm header matches all expectations\n\n\n    if (!(header.alg === this.alg && header.b64 === false && Array.isArray(header.crit) && header.crit.length === 1 && header.crit[0] === 'b64') && Object.keys(header).length === 3) {\n      throw new Error(`Invalid JWS header parameters for ${this.type}.`);\n    } // do signature verification\n\n\n    const signature = util.decodeBase64Url(encodedSignature);\n    const data = util.createJws({\n      encodedHeader,\n      verifyData\n    });\n    let {\n      verifier\n    } = this;\n\n    if (!verifier) {\n      const key = await this.LDKeyClass.from(verificationMethod);\n      verifier = key.verifier();\n    }\n\n    return verifier.verify({\n      data,\n      signature\n    });\n  }\n\n  async assertVerificationMethod(_ref3) {\n    let {\n      verificationMethod\n    } = _ref3;\n\n    if (!jsonld.hasValue(verificationMethod, 'type', this.requiredKeyType)) {\n      throw new Error(`Invalid key type. Key type must be \"${this.requiredKeyType}\".`);\n    }\n  }\n\n  async getVerificationMethod(_ref4) {\n    let {\n      proof,\n      documentLoader\n    } = _ref4;\n\n    if (this.key) {\n      return this.key.publicNode();\n    }\n\n    const verificationMethod = await super.getVerificationMethod({\n      proof,\n      documentLoader\n    });\n    await this.assertVerificationMethod({\n      verificationMethod\n    });\n    return verificationMethod;\n  }\n\n  async matchProof(_ref5) {\n    let {\n      proof,\n      document,\n      purpose,\n      documentLoader,\n      expansionMap\n    } = _ref5;\n\n    if (!(await super.matchProof({\n      proof,\n      document,\n      purpose,\n      documentLoader,\n      expansionMap\n    }))) {\n      return false;\n    }\n\n    if (!this.key) {\n      // no key specified, so assume this suite matches and it can be retrieved\n      return true;\n    }\n\n    let {\n      verificationMethod\n    } = proof;\n\n    if (!verificationMethod) {\n      verificationMethod = proof.creator;\n    } // only match if the key specified matches the one in the proof\n\n\n    if (typeof verificationMethod === 'object') {\n      return verificationMethod.id === this.key.id;\n    }\n\n    return verificationMethod === this.key.id;\n  }\n\n};","map":{"version":3,"sources":["/Users/shubhamlal/Desktop/verification/node_modules/jsonld-signatures/lib/suites/JwsLinkedDataSignature.js"],"names":["LinkedDataSignature","require","jsonld","util","module","exports","JwsLinkedDataSignature","constructor","type","alg","LDKeyClass","creator","verificationMethod","signer","key","proof","date","useNativeCanonize","undefined","publicKey","publicNode","owner","id","verifier","sign","verifyData","Error","header","b64","crit","encodedHeader","encodeBase64Url","JSON","stringify","data","createJws","signature","encodedSignature","jws","verifySignature","includes","TypeError","split","parse","decodeBase64UrlToString","e","Array","isArray","length","Object","keys","decodeBase64Url","from","verify","assertVerificationMethod","hasValue","requiredKeyType","getVerificationMethod","documentLoader","matchProof","document","purpose","expansionMap"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst LinkedDataSignature = require('./LinkedDataSignature');\nconst jsonld = require('jsonld');\nconst util = require('../util');\n\nmodule.exports = class JwsLinkedDataSignature extends LinkedDataSignature {\n  /**\n   * @param type {string} Provided by subclass.\n   * @param alg {string} JWS alg provided by subclass.\n   * @param [LDKeyClass] {LDKeyClass} provided by subclass or subclass\n   *   overrides `getVerificationMethod`.\n   *\n   * One of these parameters is required to use a suite for signing:\n   *\n   * @param [creator] {string} A key id URL to the paired public key.\n   * @param [verificationMethod] {string} A key id URL to the paired public key.\n   *\n   * This parameter is required for signing:\n   *\n   * @param [signer] {function} an optional signer.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param [proof] {object} a JSON-LD document with options to use for\n   *   the `proof` node (e.g. any other custom fields can be provided here\n   *   using a context different from security-v2).\n   * @param [date] {string|Date} signing date to use if not passed.\n   * @param [key] {LDKeyPair} an optional crypto-ld KeyPair.\n   * @param [useNativeCanonize] {boolean} true to use a native canonize\n   *   algorithm.\n   */\n  constructor({\n    type, alg, LDKeyClass, creator, verificationMethod, signer, key, proof,\n    date, useNativeCanonize} = {}) {\n    super({type, creator, verificationMethod, proof, date, useNativeCanonize});\n    this.alg = alg;\n    this.LDKeyClass = LDKeyClass;\n    this.signer = signer;\n    if(key) {\n      if(verificationMethod === undefined && creator === undefined) {\n        const publicKey = key.publicNode();\n        if(publicKey.owner) {\n          // use legacy signature terms\n          this.creator = publicKey.id;\n        } else {\n          // use newer signature terms\n          this.verificationMethod = publicKey.id;\n        }\n      }\n      this.key = key;\n      if(typeof key.signer === 'function') {\n        this.signer = key.signer();\n      }\n      if(typeof key.verifier === 'function') {\n        this.verifier = key.verifier();\n      }\n    }\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param proof {object}\n   *\n   * @returns {Promise<{object}>} the proof containing the signature value.\n   */\n  async sign({verifyData, proof}) {\n    if(!(this.signer && typeof this.signer.sign === 'function')) {\n      throw new Error('A signer API has not been specified.');\n    }\n    // JWS header\n    const header = {\n      alg: this.alg,\n      b64: false,\n      crit: ['b64']\n    };\n\n    /*\n    +-------+-----------------------------------------------------------+\n    | \"b64\" | JWS Signing Input Formula                                 |\n    +-------+-----------------------------------------------------------+\n    | true  | ASCII(BASE64URL(UTF8(JWS Protected Header)) || '.' ||     |\n    |       | BASE64URL(JWS Payload))                                   |\n    |       |                                                           |\n    | false | ASCII(BASE64URL(UTF8(JWS Protected Header)) || '.') ||    |\n    |       | JWS Payload                                               |\n    +-------+-----------------------------------------------------------+\n    */\n\n    // create JWS data and sign\n    const encodedHeader = util.encodeBase64Url(JSON.stringify(header));\n    const data = util.createJws({encodedHeader, verifyData});\n    const signature = await this.signer.sign({data});\n\n    // create detached content signature\n    const encodedSignature = util.encodeBase64Url(signature);\n    proof.jws = encodedHeader + '..' + encodedSignature;\n    return proof;\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param verificationMethod {object}.\n   * @param document {object} the document the proof applies to.\n   * @param proof {object} the proof to be verified.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{boolean}>} Resolves with the verification result.\n   */\n  async verifySignature({verifyData, verificationMethod, proof}) {\n    if(!(proof.jws && typeof proof.jws === 'string' &&\n      proof.jws.includes('.'))) {\n      throw new TypeError('The proof does not include a valid \"jws\" property.');\n    }\n    // add payload into detached content signature\n    const [encodedHeader, /*payload*/, encodedSignature] = proof.jws.split('.');\n\n    let header;\n    try {\n      header = JSON.parse(util.decodeBase64UrlToString(encodedHeader));\n    } catch(e) {\n      throw new Error('Could not parse JWS header; ' + e);\n    }\n    if(!(header && typeof header === 'object')) {\n      throw new Error('Invalid JWS header.');\n    }\n\n    // confirm header matches all expectations\n    if(!(header.alg === this.alg && header.b64 === false &&\n      Array.isArray(header.crit) && header.crit.length === 1 &&\n      header.crit[0] === 'b64') && Object.keys(header).length === 3) {\n      throw new Error(\n        `Invalid JWS header parameters for ${this.type}.`);\n    }\n\n    // do signature verification\n    const signature = util.decodeBase64Url(encodedSignature);\n    const data = util.createJws({encodedHeader, verifyData});\n    let {verifier} = this;\n    if(!verifier) {\n      const key = await this.LDKeyClass.from(verificationMethod);\n      verifier = key.verifier();\n    }\n    return verifier.verify({data, signature});\n  }\n\n  async assertVerificationMethod({verificationMethod}) {\n    if(!jsonld.hasValue(verificationMethod, 'type', this.requiredKeyType)) {\n      throw new Error(\n        `Invalid key type. Key type must be \"${this.requiredKeyType}\".`);\n    }\n  }\n\n  async getVerificationMethod({proof, documentLoader}) {\n    if(this.key) {\n      return this.key.publicNode();\n    }\n\n    const verificationMethod = await super.getVerificationMethod(\n      {proof, documentLoader});\n    await this.assertVerificationMethod({verificationMethod});\n    return verificationMethod;\n  }\n\n  async matchProof({proof, document, purpose, documentLoader, expansionMap}) {\n    if(!await super.matchProof(\n      {proof, document, purpose, documentLoader, expansionMap})) {\n      return false;\n    }\n    if(!this.key) {\n      // no key specified, so assume this suite matches and it can be retrieved\n      return true;\n    }\n\n    let {verificationMethod} = proof;\n    if(!verificationMethod) {\n      verificationMethod = proof.creator;\n    }\n    // only match if the key specified matches the one in the proof\n    if(typeof verificationMethod === 'object') {\n      return verificationMethod.id === this.key.id;\n    }\n    return verificationMethod === this.key.id;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}