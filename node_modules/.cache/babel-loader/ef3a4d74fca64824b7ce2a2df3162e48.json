{"ast":null,"code":"/*\n * Copyright (c) 2018-2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {\n  asn1,\n  oids,\n  util: {\n    ByteBuffer\n  }\n} = require('node-forge');\n/**\n * Wraps Base58 decoding operations in\n * order to provide consistent error messages.\n * @ignore\n * @example\n * > const pubkeyBytes = _base58Decode({\n *    decode: base58.decode,\n *    keyMaterial: this.publicKeyBase58,\n *    type: 'public'\n *   });\n * @param {Object} options - The decoder options.\n * @param {Function} options.decode - The decode function to use.\n * @param {string} options.keyMaterial - The Base58 encoded\n * key material to decode.\n * @param {string} options.type - A description of the\n * key material that will be included\n * in an error message (e.g. 'public', 'private').\n *\n * @returns {Object} - The decoded bytes. The data structure for the bytes is\n *   determined by the provided decode function.\n */\n\n\nexports.base58Decode = _ref => {\n  let {\n    decode,\n    keyMaterial,\n    type\n  } = _ref;\n  let bytes;\n\n  try {\n    bytes = decode(keyMaterial);\n  } catch (e) {// do nothing\n    // the bs58 implementation throws, forge returns undefined\n    // this helper throws when no result is produced\n  }\n\n  if (bytes === undefined) {\n    throw new TypeError(`The ${type} key material must be Base58 encoded.`);\n  }\n\n  return bytes;\n};\n\nexports.privateKeyDerEncode = _ref2 => {\n  let {\n    privateKeyBytes,\n    seedBytes\n  } = _ref2;\n\n  if (!(privateKeyBytes || seedBytes)) {\n    throw new TypeError('`privateKeyBytes` or `seedBytes` is required.');\n  }\n\n  if (!privateKeyBytes && !(Buffer.isBuffer(seedBytes) && seedBytes.length === 32)) {\n    throw new TypeError('`seedBytes` must be a 32 byte Buffer.');\n  }\n\n  if (!seedBytes && !(Buffer.isBuffer(privateKeyBytes) && privateKeyBytes.length === 64)) {\n    throw new TypeError('`privateKeyBytes` must be a 64 byte Buffer.');\n  }\n\n  let p;\n\n  if (seedBytes) {\n    p = seedBytes;\n  } else {\n    // extract the first 32 bytes of the 64 byte private key representation\n    p = Buffer.from(privateKeyBytes.buffer, privateKeyBytes.byteOffset, 32);\n  }\n\n  const keyBuffer = new ByteBuffer(p);\n  const asn1Key = asn1.create(asn1.UNIVERSAL, asn1.Type.OCTETSTRING, false, keyBuffer.getBytes());\n  const a = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()), // privateKeyAlgorithm\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids.EdDSA25519).getBytes())]), // private key\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(asn1Key).getBytes())]);\n  const privateKeyDer = asn1.toDer(a);\n  return Buffer.from(privateKeyDer.getBytes(), 'binary');\n};\n\nexports.publicKeyDerEncode = _ref3 => {\n  let {\n    publicKeyBytes\n  } = _ref3;\n\n  if (!(Buffer.isBuffer(publicKeyBytes) && publicKeyBytes.length === 32)) {\n    throw new TypeError('`publicKeyBytes` must be a 32 byte Buffer.');\n  } // add a zero byte to the front of the publicKeyBytes, this results in\n  // the bitstring being 256 bits vs. 170 bits (without padding)\n\n\n  const zeroBuffer = Buffer.from(new Uint8Array([0]));\n  const keyBuffer = new ByteBuffer(Buffer.concat([zeroBuffer, publicKeyBytes]));\n  const a = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids.EdDSA25519).getBytes())]), // public key\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, keyBuffer.getBytes())]);\n  const publicKeyDer = asn1.toDer(a);\n  return Buffer.from(publicKeyDer.getBytes(), 'binary');\n};","map":{"version":3,"sources":["/Users/shubhamlal/Desktop/verification/node_modules/crypto-ld/lib/util.js"],"names":["asn1","oids","util","ByteBuffer","require","exports","base58Decode","decode","keyMaterial","type","bytes","e","undefined","TypeError","privateKeyDerEncode","privateKeyBytes","seedBytes","Buffer","isBuffer","length","p","from","buffer","byteOffset","keyBuffer","asn1Key","create","UNIVERSAL","Type","OCTETSTRING","getBytes","a","Class","SEQUENCE","INTEGER","integerToDer","OID","oidToDer","EdDSA25519","toDer","privateKeyDer","publicKeyDerEncode","publicKeyBytes","zeroBuffer","Uint8Array","concat","BITSTRING","publicKeyDer"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2018-2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {asn1, oids, util: {ByteBuffer}} = require('node-forge');\n\n/**\n * Wraps Base58 decoding operations in\n * order to provide consistent error messages.\n * @ignore\n * @example\n * > const pubkeyBytes = _base58Decode({\n *    decode: base58.decode,\n *    keyMaterial: this.publicKeyBase58,\n *    type: 'public'\n *   });\n * @param {Object} options - The decoder options.\n * @param {Function} options.decode - The decode function to use.\n * @param {string} options.keyMaterial - The Base58 encoded\n * key material to decode.\n * @param {string} options.type - A description of the\n * key material that will be included\n * in an error message (e.g. 'public', 'private').\n *\n * @returns {Object} - The decoded bytes. The data structure for the bytes is\n *   determined by the provided decode function.\n */\nexports.base58Decode = ({decode, keyMaterial, type}) => {\n  let bytes;\n  try {\n    bytes = decode(keyMaterial);\n  } catch(e) {\n    // do nothing\n    // the bs58 implementation throws, forge returns undefined\n    // this helper throws when no result is produced\n  }\n  if(bytes === undefined) {\n    throw new TypeError(`The ${type} key material must be Base58 encoded.`);\n  }\n  return bytes;\n};\n\nexports.privateKeyDerEncode = ({privateKeyBytes, seedBytes}) => {\n  if(!(privateKeyBytes || seedBytes)) {\n    throw new TypeError('`privateKeyBytes` or `seedBytes` is required.');\n  }\n  if(!privateKeyBytes && !(Buffer.isBuffer(seedBytes) &&\n    seedBytes.length === 32)) {\n    throw new TypeError('`seedBytes` must be a 32 byte Buffer.');\n  }\n  if(!seedBytes && !(Buffer.isBuffer(privateKeyBytes) &&\n    privateKeyBytes.length === 64)) {\n    throw new TypeError('`privateKeyBytes` must be a 64 byte Buffer.');\n  }\n  let p;\n  if(seedBytes) {\n    p = seedBytes;\n  } else {\n    // extract the first 32 bytes of the 64 byte private key representation\n    p = Buffer.from(privateKeyBytes.buffer, privateKeyBytes.byteOffset, 32);\n  }\n  const keyBuffer = new ByteBuffer(p);\n\n  const asn1Key = asn1.create(\n    asn1.UNIVERSAL,\n    asn1.Type.OCTETSTRING,\n    false,\n    keyBuffer.getBytes()\n  );\n\n  const a = asn1.create(\n    asn1.Class.UNIVERSAL,\n    asn1.Type.SEQUENCE,\n    true, [\n      asn1.create(\n        asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n        asn1.integerToDer(0).getBytes()),\n      // privateKeyAlgorithm\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.OID,\n          false,\n          asn1.oidToDer(oids.EdDSA25519).getBytes()\n        ),\n      ]),\n      // private key\n      asn1.create(\n        asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\n        asn1.toDer(asn1Key).getBytes()),\n    ]\n  );\n\n  const privateKeyDer = asn1.toDer(a);\n  return Buffer.from(privateKeyDer.getBytes(), 'binary');\n};\n\nexports.publicKeyDerEncode = ({publicKeyBytes}) => {\n  if(!(Buffer.isBuffer(publicKeyBytes) && publicKeyBytes.length === 32)) {\n    throw new TypeError('`publicKeyBytes` must be a 32 byte Buffer.');\n  }\n  // add a zero byte to the front of the publicKeyBytes, this results in\n  // the bitstring being 256 bits vs. 170 bits (without padding)\n  const zeroBuffer = Buffer.from(new Uint8Array([0]));\n  const keyBuffer = new ByteBuffer(Buffer.concat([zeroBuffer, publicKeyBytes]));\n\n  const a = asn1.create(\n    asn1.Class.UNIVERSAL,\n    asn1.Type.SEQUENCE,\n    true, [\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.OID,\n          false,\n          asn1.oidToDer(oids.EdDSA25519).getBytes()\n        ),\n      ]),\n      // public key\n      asn1.create(\n        asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,\n        keyBuffer.getBytes()),\n    ]\n  );\n\n  const publicKeyDer = asn1.toDer(a);\n  return Buffer.from(publicKeyDer.getBytes(), 'binary');\n};\n"]},"metadata":{},"sourceType":"script"}