{"ast":null,"code":"/*!\n * Copyright (c) 2018-2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst forge = require('node-forge');\n\nconst {\n  util: {\n    binary: {\n      base58\n    }\n  }\n} = forge;\n\nclass LDKeyPair {\n  /**\n   *  Note: Actual key material\n   * (like `publicKeyBase58` for Ed25519 or\n   * `publicKeyPem` for RSA) is handled in the subclass.\n   * An LDKeyPair can encrypt private key material.\n   * @classdesc The Abstract Base Class on which KeyPairs are based.\n   * @example\n   * // LDKeyPair is an Abstract Class and should only\n   * // be used as a base class for other KeyPairs.\n   * @param {KeyPairOptions} [options={}] -\n   * See [KeyPairOptions]{@link ./index.md#KeyPairOptions}.\n   * @param {string} [options.passphrase=null] - For encrypting the private key.\n   * @param {string} options.id - The Key id.\n   * @param {string} options.controller - DID of the person/entity controlling\n   *   this key.\n   * @param {string} [options.owner]  - DID or URI of owner. DEPRECATED, use\n   *  `controller` instead.\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.passphrase = options.passphrase || null;\n    this.id = options.id;\n    this.controller = options.controller;\n    this.owner = options.owner; // this.type is set in subclass constructor\n    // this.publicKey* and this.privateKey* is handled in sub-classes\n  }\n  /**\n   * @abstract\n   * @interface\n   * @readonly\n   *  Returns the public key.\n   * @throws  If not implemented by the subclass.\n   *\n   * @returns {string} A public key.\n   */\n\n\n  get publicKey() {\n    throw new Error('Abstract method, must be implemented in subclass.');\n  }\n  /**\n   * @abstract\n   * @interface\n   * @readonly\n   *  Returns the private key.\n   * @throws If not implemented by the subclass.\n   *\n   * @returns {string} A private key.\n   */\n\n\n  get privateKey() {\n    throw new Error('Abstract method, must be implemented in subclass.');\n  }\n  /**\n   * Generates an LdKeyPair using SerializedLdKey options.\n   * @param {SerializedLdKey} options - Options for generating the KeyPair.\n   * @example\n   * > const options = {\n   *    type: 'RsaVerificationKey2018',\n   *    passphrase: 'Test1234'\n   *  };\n   * > const keyPair = await LDKeyPair.generate(options);\n   *\n   * @returns {Promise<LDKeyPair>} An LDKeyPair.\n   * @throws Unsupported Key Type.\n   * @see [SerializedLdKey]{@link ./index.md#SerializedLdKey}\n   */\n\n\n  static async generate(options) {\n    switch (options.type) {\n      case 'Ed25519VerificationKey2018':\n        const Ed25519KeyPair = require('./Ed25519KeyPair');\n\n        return Ed25519KeyPair.generate(options);\n\n      case 'RsaVerificationKey2018':\n        const RSAKeyPair = require('./RSAKeyPair');\n\n        return RSAKeyPair.generate(options);\n\n      default:\n        throw new Error(`Unsupported Key Type: ${options.type}`);\n    }\n  }\n  /**\n   * Generates a KeyPair from some options.\n   * @param {SerializedLdKey} options  - Will generate a key pair\n   * in multiple different formats.\n   * @see [SerializedLdKey]{@link ./index.md#SerializedLdKey}\n   * @example\n   * > const options = {\n   *    type: 'Ed25519VerificationKey2018',\n   *    passphrase: 'Test1234'\n   *   };\n   * > const edKeyPair = await LDKeyPair.from(options);\n   *\n   * @returns {Promise<LDKeyPair>} A LDKeyPair.\n   * @throws Unsupported Key Type.\n   */\n\n\n  static async from(options) {\n    switch (options.type) {\n      case 'Ed25519VerificationKey2018':\n        const Ed25519KeyPair = require('./Ed25519KeyPair');\n\n        return Ed25519KeyPair.from(options);\n\n      case 'RsaVerificationKey2018':\n        const RSAKeyPair = require('./RSAKeyPair');\n\n        return RSAKeyPair.from(options);\n\n      default:\n        throw new Error(`Unsupported Key Type: ${options.type}`);\n    }\n  }\n  /**\n   * Creates an instance of LDKeyPair from a key fingerprint.\n   * Note: Only key types that use their full public key in the fingerprint\n   * are supported (so, currently, only 'ed25519').\n   *\n   * @param {string} fingerprint\n   * @returns {LDKeyPair}\n   * @throws Unsupported Fingerprint Type.\n   */\n\n\n  static fromFingerprint(_ref) {\n    let {\n      fingerprint\n    } = _ref;\n    // skip leading `z` that indicates base58 encoding\n    const buffer = base58.decode(fingerprint.substr(1)); // buffer is: 0xed 0x01 <public key bytes>\n\n    if (buffer[0] === 0xed && buffer[1] === 0x01) {\n      const Ed25519KeyPair = require('./Ed25519KeyPair');\n\n      return new Ed25519KeyPair({\n        publicKeyBase58: base58.encode(buffer.slice(2))\n      });\n    }\n\n    throw new Error(`Unsupported Fingerprint Type: ${fingerprint}`);\n  }\n  /**\n   * Generates a\n   * [pdkdf2]{@link https://en.wikipedia.org/wiki/PBKDF2} key.\n   * @param {string} password - The password for the key.\n   * @param {string} salt - Noise used to randomize the key.\n   * @param {number} iterations - The number of times to run the algorithm.\n   * @param {number} keySize - The byte length of the key.\n   * @example\n   * > const key = await LdKeyPair.pbkdf2('Test1234', salt, 10, 32);\n   *\n   * @returns {Promise<Object>} A promise that resolves to a pdkdf2 key.\n   * @see https://github.com/digitalbazaar/forge#pkcs5\n   */\n\n\n  static async pbkdf2(password, salt, iterations, keySize) {\n    return new Promise((resolve, reject) => {\n      forge.pkcs5.pbkdf2(password, salt, iterations, keySize, (err, key) => err ? reject(err) : resolve(key));\n    });\n  }\n  /**\n   * Contains the encryption type & public key for the KeyPair\n   * and other information that json-ld Signatures can use to form a proof.\n   * @param {Object} [options={}] - Needs either a controller or owner.\n   * @param {string} [options.controller=this.controller]  - DID of the\n   * person/entity controlling this key pair.\n   * @param {string} [options.owner=this.owner] - DID of key owner.\n   * Deprecated term, use `controller`.\n   * @example\n   * > ldKeyPair.publicNode();\n   * {id: 'test-keypair-id', owner: 'did:uuid:example'}\n   *\n   * @returns {Object} A public node with\n   * information used in verification methods by signatures.\n   */\n\n\n  publicNode() {\n    let {\n      controller = this.controller,\n      owner = this.owner\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const publicNode = {\n      id: this.id,\n      type: this.type\n    };\n\n    if (controller) {\n      publicNode.controller = controller;\n    }\n\n    if (owner) {\n      publicNode.owner = owner;\n    }\n\n    this.addEncodedPublicKey(publicNode); // Subclass-specific\n\n    return publicNode;\n  } // publicKeyPem, publicKeyJwk, publicKeyHex, publicKeyBase64, publicKeyBase58\n\n  /**\n   * Exports the publicNode with an encrypted private key attached.\n   * @example\n   * > const withPrivateKey = await edKeyPair.export();\n   *\n   * @returns {KeyPairOptions} A public node with encrypted private key.\n   * @see [KeyPairOptions]{@link ./index.md#KeyPairOptions}\n   */\n\n\n  async export() {\n    const keyNode = this.publicNode();\n    return this.addEncryptedPrivateKey(keyNode); // Subclass-specific\n  }\n\n}\n\nmodule.exports = LDKeyPair;","map":{"version":3,"sources":["/Users/shubhamlal/Desktop/verification/node_modules/crypto-ld/lib/LDKeyPair.js"],"names":["forge","require","util","binary","base58","LDKeyPair","constructor","options","passphrase","id","controller","owner","publicKey","Error","privateKey","generate","type","Ed25519KeyPair","RSAKeyPair","from","fromFingerprint","fingerprint","buffer","decode","substr","publicKeyBase58","encode","slice","pbkdf2","password","salt","iterations","keySize","Promise","resolve","reject","pkcs5","err","key","publicNode","addEncodedPublicKey","export","keyNode","addEncryptedPrivateKey","module","exports"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2018-2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst forge = require('node-forge');\nconst {util: {binary: {base58}}} = forge;\n\nclass LDKeyPair {\n  /**\n   *  Note: Actual key material\n   * (like `publicKeyBase58` for Ed25519 or\n   * `publicKeyPem` for RSA) is handled in the subclass.\n   * An LDKeyPair can encrypt private key material.\n   * @classdesc The Abstract Base Class on which KeyPairs are based.\n   * @example\n   * // LDKeyPair is an Abstract Class and should only\n   * // be used as a base class for other KeyPairs.\n   * @param {KeyPairOptions} [options={}] -\n   * See [KeyPairOptions]{@link ./index.md#KeyPairOptions}.\n   * @param {string} [options.passphrase=null] - For encrypting the private key.\n   * @param {string} options.id - The Key id.\n   * @param {string} options.controller - DID of the person/entity controlling\n   *   this key.\n   * @param {string} [options.owner]  - DID or URI of owner. DEPRECATED, use\n   *  `controller` instead.\n   */\n  constructor(options = {}) {\n    this.passphrase = options.passphrase || null;\n    this.id = options.id;\n    this.controller = options.controller;\n    this.owner = options.owner;\n    // this.type is set in subclass constructor\n    // this.publicKey* and this.privateKey* is handled in sub-classes\n  }\n  /**\n   * @abstract\n   * @interface\n   * @readonly\n   *  Returns the public key.\n   * @throws  If not implemented by the subclass.\n   *\n   * @returns {string} A public key.\n   */\n  get publicKey() {\n    throw new Error('Abstract method, must be implemented in subclass.');\n  }\n  /**\n   * @abstract\n   * @interface\n   * @readonly\n   *  Returns the private key.\n   * @throws If not implemented by the subclass.\n   *\n   * @returns {string} A private key.\n   */\n  get privateKey() {\n    throw new Error('Abstract method, must be implemented in subclass.');\n  }\n  /**\n   * Generates an LdKeyPair using SerializedLdKey options.\n   * @param {SerializedLdKey} options - Options for generating the KeyPair.\n   * @example\n   * > const options = {\n   *    type: 'RsaVerificationKey2018',\n   *    passphrase: 'Test1234'\n   *  };\n   * > const keyPair = await LDKeyPair.generate(options);\n   *\n   * @returns {Promise<LDKeyPair>} An LDKeyPair.\n   * @throws Unsupported Key Type.\n   * @see [SerializedLdKey]{@link ./index.md#SerializedLdKey}\n   */\n  static async generate(options) {\n    switch(options.type) {\n      case 'Ed25519VerificationKey2018':\n        const Ed25519KeyPair = require('./Ed25519KeyPair');\n        return Ed25519KeyPair.generate(options);\n\n      case 'RsaVerificationKey2018':\n        const RSAKeyPair = require('./RSAKeyPair');\n        return RSAKeyPair.generate(options);\n\n      default:\n        throw new Error(`Unsupported Key Type: ${options.type}`);\n    }\n  }\n\n  /**\n   * Generates a KeyPair from some options.\n   * @param {SerializedLdKey} options  - Will generate a key pair\n   * in multiple different formats.\n   * @see [SerializedLdKey]{@link ./index.md#SerializedLdKey}\n   * @example\n   * > const options = {\n   *    type: 'Ed25519VerificationKey2018',\n   *    passphrase: 'Test1234'\n   *   };\n   * > const edKeyPair = await LDKeyPair.from(options);\n   *\n   * @returns {Promise<LDKeyPair>} A LDKeyPair.\n   * @throws Unsupported Key Type.\n   */\n  static async from(options) {\n    switch(options.type) {\n      case 'Ed25519VerificationKey2018':\n        const Ed25519KeyPair = require('./Ed25519KeyPair');\n        return Ed25519KeyPair.from(options);\n\n      case 'RsaVerificationKey2018':\n        const RSAKeyPair = require('./RSAKeyPair');\n        return RSAKeyPair.from(options);\n\n      default:\n        throw new Error(`Unsupported Key Type: ${options.type}`);\n    }\n  }\n\n  /**\n   * Creates an instance of LDKeyPair from a key fingerprint.\n   * Note: Only key types that use their full public key in the fingerprint\n   * are supported (so, currently, only 'ed25519').\n   *\n   * @param {string} fingerprint\n   * @returns {LDKeyPair}\n   * @throws Unsupported Fingerprint Type.\n   */\n  static fromFingerprint({fingerprint}) {\n    // skip leading `z` that indicates base58 encoding\n    const buffer = base58.decode(fingerprint.substr(1));\n\n    // buffer is: 0xed 0x01 <public key bytes>\n    if(buffer[0] === 0xed && buffer[1] === 0x01) {\n      const Ed25519KeyPair = require('./Ed25519KeyPair');\n      return new Ed25519KeyPair({\n        publicKeyBase58: base58.encode(buffer.slice(2))\n      });\n    }\n\n    throw new Error(`Unsupported Fingerprint Type: ${fingerprint}`);\n  }\n\n  /**\n   * Generates a\n   * [pdkdf2]{@link https://en.wikipedia.org/wiki/PBKDF2} key.\n   * @param {string} password - The password for the key.\n   * @param {string} salt - Noise used to randomize the key.\n   * @param {number} iterations - The number of times to run the algorithm.\n   * @param {number} keySize - The byte length of the key.\n   * @example\n   * > const key = await LdKeyPair.pbkdf2('Test1234', salt, 10, 32);\n   *\n   * @returns {Promise<Object>} A promise that resolves to a pdkdf2 key.\n   * @see https://github.com/digitalbazaar/forge#pkcs5\n   */\n  static async pbkdf2(password, salt, iterations, keySize) {\n    return new Promise((resolve, reject) => {\n      forge.pkcs5.pbkdf2(password, salt, iterations, keySize, (err, key) =>\n        err ? reject(err) : resolve(key));\n    });\n  }\n\n  /**\n   * Contains the encryption type & public key for the KeyPair\n   * and other information that json-ld Signatures can use to form a proof.\n   * @param {Object} [options={}] - Needs either a controller or owner.\n   * @param {string} [options.controller=this.controller]  - DID of the\n   * person/entity controlling this key pair.\n   * @param {string} [options.owner=this.owner] - DID of key owner.\n   * Deprecated term, use `controller`.\n   * @example\n   * > ldKeyPair.publicNode();\n   * {id: 'test-keypair-id', owner: 'did:uuid:example'}\n   *\n   * @returns {Object} A public node with\n   * information used in verification methods by signatures.\n   */\n  publicNode({controller = this.controller, owner = this.owner} = {}) {\n    const publicNode = {\n      id: this.id,\n      type: this.type,\n    };\n    if(controller) {\n      publicNode.controller = controller;\n    }\n    if(owner) {\n      publicNode.owner = owner;\n    }\n    this.addEncodedPublicKey(publicNode); // Subclass-specific\n    return publicNode;\n  }\n\n  // publicKeyPem, publicKeyJwk, publicKeyHex, publicKeyBase64, publicKeyBase58\n  /**\n   * Exports the publicNode with an encrypted private key attached.\n   * @example\n   * > const withPrivateKey = await edKeyPair.export();\n   *\n   * @returns {KeyPairOptions} A public node with encrypted private key.\n   * @see [KeyPairOptions]{@link ./index.md#KeyPairOptions}\n   */\n  async export() {\n    const keyNode = this.publicNode();\n    return this.addEncryptedPrivateKey(keyNode); // Subclass-specific\n  }\n}\n\nmodule.exports = LDKeyPair;\n"]},"metadata":{},"sourceType":"script"}